% Declaring a corner folder paper for use in illustrations.
\makeatletter
\pgfdeclareshape{paper}{
	\inheritsavedanchors[from=rectangle] % this is nearly a rectangle
	\inheritanchorborder[from=rectangle]
	\inheritanchor[from=rectangle]{center}
	\inheritanchor[from=rectangle]{north}
	\inheritanchor[from=rectangle]{south}
	\inheritanchor[from=rectangle]{west}
	\inheritanchor[from=rectangle]{east}
	\inheritanchor[from=rectangle]{north west}
	\inheritanchor[from=rectangle]{north east}
	\inheritanchor[from=rectangle]{south west}
	\inheritanchor[from=rectangle]{south east}

	\backgroundpath{% this is new
		% store lower right in xa/ya and upper right in xb/yb
		\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
		\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
		% compute corner of ‘‘flipped page’’
		\pgf@xc=\pgf@xb \advance\pgf@xc by-10pt % this should be a parameter
		\pgf@yc=\pgf@yb \advance\pgf@yc by-10pt
		% construct main path
		\pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yc}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
		\pgfpathclose
		% add little corner
		\pgfpathmoveto{\pgfpoint{\pgf@xc}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yc}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yc}}
		\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yc}}
	}
}
\pgfdeclareshape{bottomrect}{
	\inheritsavedanchors[from=rectangle]
	\inheritanchorborder[from=rectangle]
	\inheritanchor[from=rectangle]{center}
	\inheritanchor[from=rectangle]{north}
	\inheritanchor[from=rectangle]{south}
	\inheritanchor[from=rectangle]{west}
	\inheritanchor[from=rectangle]{east}
	\inheritanchor[from=rectangle]{north west}
	\inheritanchor[from=rectangle]{north east}
	\inheritanchor[from=rectangle]{south west}
	\inheritanchor[from=rectangle]{south east}

	\backgroundpath{%
		% store lower right in xa/ya and upper right in xb/yb
		\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
		\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y

		\pgfpathmoveto{\pgfpoint{\pgf@xb}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@yb}}
	}
}
\pgfdeclareshape{rightrect}{
	\inheritsavedanchors[from=rectangle]
	\inheritanchorborder[from=rectangle]
	\inheritanchor[from=rectangle]{center}
	\inheritanchor[from=rectangle]{north}
	\inheritanchor[from=rectangle]{south}
	\inheritanchor[from=rectangle]{west}
	\inheritanchor[from=rectangle]{east}
	\inheritanchor[from=rectangle]{north west}
	\inheritanchor[from=rectangle]{north east}
	\inheritanchor[from=rectangle]{south west}
	\inheritanchor[from=rectangle]{south east}

	\backgroundpath{%
		% store lower right in xa/ya and upper right in xb/yb
		\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
		\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y

		\pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@ya}}
	}
}
\pgfdeclareshape{rightleftrect}{
	\inheritsavedanchors[from=rectangle]
	\inheritanchorborder[from=rectangle]
	\inheritanchor[from=rectangle]{center}
	\inheritanchor[from=rectangle]{north}
	\inheritanchor[from=rectangle]{south}
	\inheritanchor[from=rectangle]{west}
	\inheritanchor[from=rectangle]{east}
	\inheritanchor[from=rectangle]{north west}
	\inheritanchor[from=rectangle]{north east}
	\inheritanchor[from=rectangle]{south west}
	\inheritanchor[from=rectangle]{south east}

	\backgroundpath{%
		% store lower right in xa/ya and upper right in xb/yb
		\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
		\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y

		\pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
		\pgfpathmoveto{\pgfpoint{\pgf@xb}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@ya}}
	}
}
\pgfdeclareshape{rect}{
	\inheritsavedanchors[from=rectangle]
	\inheritanchorborder[from=rectangle]
	\inheritanchor[from=rectangle]{center}
	\inheritanchor[from=rectangle]{north}
	\inheritanchor[from=rectangle]{south}
	\inheritanchor[from=rectangle]{west}
	\inheritanchor[from=rectangle]{east}
	\inheritanchor[from=rectangle]{north west}
	\inheritanchor[from=rectangle]{north east}
	\inheritanchor[from=rectangle]{south west}
	\inheritanchor[from=rectangle]{south east}

	\backgroundpath{%
		% store lower right in xa/ya and upper right in xb/yb
		\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
		\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y

		\pgfpathmoveto{\pgfpoint{\pgf@xb}{\pgf@yb}}
		\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@ya}}
		\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@yb}}
		\pgfclosepath
	}
}
\makeatother

%%%% Large figures are put here.

% Figure of adding and removing of authoritive members of the blockchain. Arg 1 is the figure text.
\newcommand{\figMembership}[2]{
\tikzset{%
	>=latex, % Changes the default arrow head style.
	block/.style = {draw, thick, shape=rectangle, inner sep=0.4cm, align=left},
	list/.style = {draw, thick, shape=paper, inner sep=0.4cm, align=left},
	brace/.style = {thick, decoration={amplitude=3pt, brace, raise=0.0cm}, decorate}
}

\begin{figure}[H]
\centering
\begin{tikzpicture}

	% The null block should have a width and height of minipage.size + 2*(inner sep) of the other
	% blocks to remain the same size.
	\node (null) [draw=none, minimum height=3.1cm, minimum width=3.1cm] {\Large \texttt{null}};

	\node (block0) [block, right=0.83cm of null] {
		\begin{minipage}[t][2.3cm]{2.3cm}
		\texttt{Add: A\\ Add: B\\ Add: C\\ Sig: \{\}}
		\end{minipage}
	};

	\node (block1) [block, right=0.83cm of block0] {
		\begin{minipage}[t][2.3cm]{2.3cm}
		\texttt{Add: D\\ Rmv: C\\ Sig: \{A,B\}}
		\end{minipage}
	};

	\node (listnull) [list, below=1cm of null] {
		\begin{minipage}[t][2.5cm]{2.1cm}
		Membership List:
		\end{minipage}
	};

	\node (list0) [list, below=1cm of block0] {
		\begin{minipage}[t][2.5cm]{2.1cm}
		Membership List: \\
		\texttt{
			\-\hspace{1em}-A\\
			\-\hspace{1em}-B\\
			\-\hspace{1em}-C}
		\end{minipage}
	};

	\node (list1) [list, below=1cm of block1] {
		\begin{minipage}[t][2.5cm]{2.1cm}
		Membership List: \\
		\texttt{
			\-\hspace{1em}-A\\
			\-\hspace{1em}-B\\
			\-\hspace{1em}-D}
		\end{minipage}
	};

	% Draws letters so they can be referred to later.
	\node[draw=none, below=0.2cm of listnull] {\small (a)};
	\node[draw=none, below=0.2cm of list0] {\small (b)};
	\node[draw=none, below=0.2cm of list1] {\small (c)};
	% Draw block names.
	\node[draw=none, above=0.2cm of block0] {\small block 0};
	\node[draw=none, above=0.2cm of block1] {\small block 1};

	% Draws event arrows for block 1.
	\draw[brace, decoration={mirror}]
		($ (block1) + (0.2,0.45) $) -- ($ (block1) + (0.2,1.15) $)
		node[midway, xshift=2.0] (group) {};
	\draw[->, dashed, thick]  (group) .. controls ($ (block1) + (3,0.5) $) and
			($ (list1) + (3,-0.3) $) .. ($ (list1) + (0,-0.55) $);
	\draw[->, dashed, thick] ($ (list1) + (0,-0.75) $) -- ++(2,0)
			node[anchor=west] {\texttt{C}};

	% Connects the nodes/blocks by an arrow pointing to the pervious block
	\draw[<-, thick] (null) -- (block0);
	\draw[<-, thick] (block0) -- (block1);
	\draw[<->, thick] (block0) -- (list0);
	\draw[<->, thick] (block1) -- (list1);

\end{tikzpicture}
\caption{#1}
\label{fig:membership}
\caption*{#2}
\end{figure}
}

% Figure of adding and removing of authoritive members of the blockchain. Arg 1 is the figure text.
\newcommand{\figBlockTxStructure}[2]{
\tikzset{%
	every node/.style = {node font=\footnotesize},
	firstchunk/.style = {draw, thick, shape=rect, minimum height=0.5cm, minimum width=2.4cm,
			inner sep=0cm, align=center},
	chunk/.style = {draw, thick, shape=bottomrect, minimum height=0.5cm, minimum width=2.4cm,
			inner sep=0cm, align=center},
	firstfield/.style = {draw, thick, shape=rect, minimum height=0.5cm, minimum width=1.4cm,
			inner sep=0cm, align=center},
	field/.style = {draw, thick, shape=rightrect, minimum height=0.5cm, minimum width=1.4cm,
			inner sep=0cm, align=center},
	firstdata/.style = {draw, thick, shape=rect, minimum height=1cm, minimum width=0.4cm},
	data/.style = {draw, thick, shape=rightrect, minimum height=1cm, minimum width=0.4cm},
	dataend/.style = {draw, thick, shape=rightleftrect, minimum height=1cm, minimum width=0.4cm},
	brace/.style = {thick, decoration={amplitude=6pt, brace, raise=0.1cm}, decorate}
}

\begin{figure}[H]
\centering
\begin{tikzpicture}

	% The block itself on the left.
	\node (chunk0) [firstchunk, minimum height=1cm] {\texttt{\small Blockheader} \\ $\vdots$};
	\node (chunk1) [chunk, below=0cm of chunk0] {\texttt{\small \#Tx}};
	\node (chunk2) [chunk, below=0cm of chunk1] {\texttt{\small Tx}};
	\node (chunk3) [chunk, below=0cm of chunk2] {\texttt{\small Tx}};
	\node (chunk4) [chunk, below=0cm of chunk3] {\texttt{\small Tx}};
	\node (chunk5) [chunk, minimum height=1.2cm, below=0cm of chunk4] {\texttt{\small Data}};

	% Showing #Tx as the number of transactions.
	\draw[brace, decoration={mirror}]
			($ (chunk2.north west) + (-0.05,0) $) -- ($(chunk4.south west) + (-0.05,0) $)
			node[midway, xshift=-0.7cm] {\#Tx};

	% The structure of a transaction header
	\node (field0) [firstfield, right=2cm of chunk0] {\texttt{\small Type}};
	\node (field1) [field, right=0cm of field0] {\texttt{\small Size}};
	\node (field2) [field, right=0cm of field1] {\texttt{\small Pointer}};

	% The expanded data array
	\node (data0) [firstdata, right=1.2cm of chunk5] {};
	\foreach \x in {1, ..., 10} {%
		\pgfmathsetmacro\oneless{\x-1}
		\node [data, right=0cm of data\oneless] (data\x) {};
	}
	\node (dataend) [dataend, right=0cm of data10] {$\dots$};

	\node (ptrsize) [above right=0.1cm and -0.1cm of dataend, align=left]
			{Pointer + Size};

	% Descriptions
	\node [above=0.1cm of chunk0] {Block};
	\node [above=0.1cm of field1] {Transaction Header};

	% Draw appropriate connections
	\draw[thick] (chunk2.east) -| ++(1,0) |- (field0); % Transaction
	\draw[thick] (chunk5) -- (data0); % Data
	\draw[->, thick] (field2.south) |- ++(0,-1) -| (data3.north west); % Transaction -> data
	\draw[brace] ($ (data3.north west) + (0.1,0) $) -- ($(dataend.north west) + (-0.1,0) $) % tx data
			node[midway, yshift=0.6cm] {Tx data};
	\draw[->, thick] (ptrsize) -| (dataend.north west); % pointer + size

\end{tikzpicture}
\caption{#1}
\label{fig:block_tx_structure}
\caption*{#2}
\end{figure}
}

\newcommand{\figMerkleTree}[2]{
\tikzset{%
  >=latex,
  every node/.style = {node font=\footnotesize},
  hash/.style = {draw, thick, minimum height=0.5cm, minimum width=1.1cm,
      inner sep=4pt, align=center},
  tx/.style = {draw, thick, minimum height=0.5cm, minimum width=1.1cm,
      inner sep=4pt, align=center},
}

\begin{figure}[H]
\centering
\begin{tikzpicture}

  % Merkle Tree
  \node (root) [hash] {\texttt{Root Hash}};
  \node (hash01) [hash, below left=1cm and 0cm of root] {\texttt{Hash01}};
  \node (hash23) [hash, below right=1cm and 0cm of root] {\texttt{Hash23}};
  \node (hash0) [hash, below left=1cm and -0.5cm of hash01] {\texttt{Hash0}};
  \node (hash1) [hash, below right=1cm and -0.5cm of hash01] {\texttt{Hash1}};
  \node (hash2) [hash, below left=1cm and -0.5cm of hash23] {\texttt{Hash2}};
  \node (hash3) [hash, below right=1cm and -0.5cm of hash23] {\texttt{Hash3}};

  % Transactions
  \node (tx0) [tx, below=1cm of hash0] {\texttt{Tx0}};
  \node (tx1) [tx, below=1cm of hash1] {\texttt{Tx1}};
  \node (tx2) [tx, below=1cm of hash2] {\texttt{Tx2}};
  \node (tx3) [tx, below=1cm of hash3] {\texttt{Tx3}};
  \node (txdesc) [draw=none, right=0.3cm of tx3] {Transactions};

  % Group transactions
  \draw[thick,dotted] ($(tx0.north west)+(-0.3,0.3)$) rectangle ($(txdesc.south east)+(0.3,-0.3)$);

  % Draw tree description
  \node[thick,draw=none, left=0.2cm of hash01] 
    {\tiny$\mathit{Hash01}=\mathrm{HASH}(\mathit{Hash0}+\mathit{Hash1})$};
  \node[thick,draw=none, left=0.2cm of hash0] 
    {\tiny$\mathit{Hash0}=\mathrm{HASH}(\mathit{Tx0})$};

  % Draw appropriate connections
  \draw[thick,->] (hash0) -- (hash01); 
  \draw[thick,->] (hash1) -- (hash01); 
  \draw[thick,->] (hash2) -- (hash23); 
  \draw[thick,->] (hash3) -- (hash23); 
  \draw[thick,->] (hash01) -- (root); 
  \draw[thick,->] (hash23) -- (root); 

  \draw[thick,->] (tx0) -- (hash0); 
  \draw[thick,->] (tx1) -- (hash1); 
  \draw[thick,->] (tx2) -- (hash2); 
  \draw[thick,->] (tx3) -- (hash3); 

\end{tikzpicture}
\caption{#1}
\label{fig:basic_merkle_tree}
\caption*{#2}
\end{figure}
}


\newcommand{\figProgramFlow}[2]{

\tikzset{%
  >=latex,
  every node/.style = {draw, rectangle, minimum size=1cm, font=\tiny},
  main/.style = {thick, align=center},
  server/.style = {thick, align=center},
  mining/.style = {thick, align=center},
  protocol/.style = {thick, align=center},
  networking/.style = {thick, align=center},
  database/.style = {thick, align=center},
  loop/.style = {fill=blue!10},
}

\begin{figure}[H]
\centering
\begin{tikzpicture}

  \newlength\xspacing
  \setlength{\xspacing}{0.2cm}
  \newlength\yspacing
  \setlength{\yspacing}{0.7cm}

  \pgfdeclarelayer{bg}    % declare background layer
  \pgfsetlayers{bg,main}  % set the order of the layers (main is the standard layer)

  % Program flow chart nodes

  % Level 0
  \node (main) [main] {Main};

  % Level 1
  \node (server) [server, below=\yspacing of main] {Server};

  % Level 2
  \node (rpcsrv) [networking, loop, below=\yspacing of server] {RPC\\Server};
  \node (upnp) [networking, loop, right=\xspacing of rpcsrv] {UPNP\\Update\\Thread};
  \node (rebroad) [networking, loop, right=\xspacing of upnp] {Rebroadcast\\Handler};
  \node (peer) [networking, loop, right=\xspacing of rebroad] {Peer\\Handler};
  \node (lishand) [networking, loop, right=\xspacing of peer] {Listen\\Handlers};
  \node (addrindex) [database, left=\xspacing+0.4cm of rpcsrv] {Address\\Indexer};
  \node (miner) [mining, left=\xspacing+1.4cm of addrindex] {CPUMiner};

  % Level 3+
  % Peer handler
  \node (addrman) [networking, below=\yspacing of peer] {Address\\Manager};
  \node (blockman) [networking, right=\xspacing of addrman] {Block\\Manager};
  \node (addrhand) [networking, loop, below=\yspacing of addrman] {Address\\Handler};
  \node (blockhand) [networking, loop, below=\yspacing of blockman] {Block\\Handler};

  % CPU miner
  \node (speed) [mining, loop, below=\yspacing of miner] {Speed\\Monitor};
  \node (mwc) [mining, loop, left=\xspacing of speed] {Mining\\Worker\\Controller};

  % addrIndexer
  \node (idxman) [database, loop, below=\yspacing of addrindex] {Index\\Manager};
  \node (idxw) [database, loop, left=\xspacing of idxman] {Index\\Writer};

  % rpcServer
  \node (rpcweb) [networking, below=\yspacing of rpcsrv] {RPC\\WebSocket};
  \node (queue) [networking, loop, below=\yspacing of rpcweb] {Queue\\Handler};
  \node (notfhand) [networking, loop, right=\xspacing of queue] {Notification\\Handler};
  
  % Draw appropriate connections
  \coordinate (mserver) at ($(server.south) - (0, \yspacing / 2)$);
  \draw[thick,->] (main) -- (server.north);
  \draw[thick] (server) -- (mserver);
  \draw[thick,->] (mserver) -| (peer.north);
  \draw[thick,->] (mserver) -| (rebroad.north);
  \draw[thick,->] (mserver) -| (rpcsrv.north);
  \draw[thick,->] (mserver) -| (miner.north);
  \draw[thick,->] (mserver) -| (addrindex.north);
  \draw[thick,->] (mserver) -| (lishand.north);
  \draw[thick,->] (mserver) -| (upnp.north);

  % Peer handler connections
  \draw[thick,->] (peer) -- (addrman.north);
  \draw[thick,->] (peer.south east) -- (blockman.north);
  \draw[thick,->] (addrman) -- (addrhand.north);
  \draw[thick,->] (blockman) -- (blockhand.north);

  % CpuMiner connections
  \draw[thick,->] (miner) -- (speed.north);
  \draw[thick,->] (miner.south west) -- (mwc.north);

  % addrIndex
  \draw[thick,->] (addrindex) -- (idxman.north);
  \draw[thick,->] (addrindex.south west) -- (idxw.north);

  % rpcServer
  \draw[thick,->] (rpcsrv) -- (rpcweb.north);
  \draw[thick,->] (rpcweb.south east) -- (notfhand.north);
  \draw[thick,->] (rpcweb) -- (queue.north);

  % Group boxes
  \begin{pgfonlayer}{bg}
    \node[rectangle,label=below:Protocol/Networking,fit=(rpcsrv)(blockhand)(rpcweb)]{};
    \node[rectangle,label=below:Database,fit=(idxw)(addrindex)]{};
    \node[rectangle,label=below:Mining,fit=(mwc)(miner)]{};
  \end{pgfonlayer}


\end{tikzpicture}
\caption{#1}
\label{fig:program_flow}
\caption*{#2}
\end{figure}
}