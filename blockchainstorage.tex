\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{float}
\usepackage{titling}
\usepackage[nottoc]{tocbibind}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listings-golang}
\usepackage[font=footnotesize]{caption}
\usepackage{subcaption}
\usepackage{pageslts}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[hidelinks]{hyperref}

\usetikzlibrary{shapes, arrows, positioning, calc, patterns, decorations.pathreplacing}

\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{brblue}{rgb}{0.1,0.4,0.9}
\definecolor{calmblue}{rgb}{0.35,0.6,0.8}
\definecolor{lightgray}{rgb}{0.95,0.95,0.95}

\DeclareCaptionFont{white}{\color{white}\sffamily}
\DeclareCaptionFormat{listing}{\colorbox{calmblue}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% Formatting all lstlisting for go code
\lstset{
    aboveskip=0pt,
    backgroundcolor=\color{lightgray},
    basicstyle={\footnotesize\ttfamily},
    belowcaptionskip=-1pt,
    breakatwhitespace=true,
    breaklines=true,
    commentstyle=\color{dkgreen},
    frame=l,
    keywordstyle=\color{brblue},
    language=Golang,
    numbers=right,
    numberstyle=\footnotesize\ttfamily\color{gray},
    numbersep=1pt,
    showstringspaces=false, 
    stringstyle=\color{mauve},
    tabsize=4,
    xleftmargin=3.4pt,
    xrightmargin=3.4pt,
}

% Hyphenation rules
\hyphenation{block-chain}

\graphicspath{ {./graphics/} }

% \figMembership defined in this file.
% \figBlockTxStructure defined in this file.
\input{figures.tex}

%\setcounter{page}{1}
\title{Verifying Diploma with Blockchain Technology}
\author{Kenneth Susort \and Christer Jensen}
\date{\today}

\setlength{\parindent}{3em}
\setlength{\parskip}{1em}

\begin{document}
\pagenumbering{arabic}

\begin{titlepage}
 \begin{center}
  
  \huge
  \textbf{\thetitle}
  
  \vspace{0.5cm}
  \large
  How can the Bitcoin technology be used\\ for validating academic diplomas?
  
  \vspace{0.5cm}
  
  \textbf{\theauthor}
  
  \vfill
  
  A thesis presented for the degree of\\
  Bachelor in Computer Science
  
  \vspace{0.8cm}
  
  \includegraphics[width=0.2\textwidth]{university_logo.png}\\
  \large
  IDE\\
  University of Stavanger\\
  Norway\\
  \thedate
  
 \end{center}
\end{titlepage}

\pagenumbering{roman}

\begin{center}
 \vspace*{4cm}
 \textbf{\textit{Abstract}}
\end{center}


This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes.
\newpage

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{\theCurrentPage}

\section{Introduction}

Blockchain is a technology which is used in different types of cryptocurrency. Cryptocurrency is a medium of exchange or currency and is entirely digital. It is made possible by utilizing certain principles of cryptography to secure transactions and to control the creation of new coins added to the circulation. What differs cryptocurrency from the normal banking system is how the currency is controlled. Regular banking systems use what is called centralized control, where the banks alone are in control over what money is spent where. Cryptocurrencies uses a decentralized system, which hands over control of the currency to its users and contributors. Such a system relies completely on the assumption that there are more honest than dishonest users. Due to this, the more a cryptocurrency grows, the more secure it becomes. 

% Rewrite the below section.
Falsified diplomas are something a lot of institutions struggle with. This thesis proposes a solution to this problem, by using blockchain technology to store hashes of diplomas in series. The hashes are then hashed together using a Merkle tree hash structure. This allows storage of an unchangeable hash that only the publisher of the original diploma would be able to prove ownership of. Attempts of changing stored documents will change every hash after said document, due to the blockchain structure. The goal is to design a hybrid consortium blockchain, which would use signatures from different institutions to validate a diploma, and locking it in the blockchain with proof-of-work. 

\section{Background}
The background section explains what the blockchain is, and what purpose the blockchain serves. The blockchain can be seen as a huge linked list of blocks containing transactions. What the different aspects and developments of cryptocurrency and the blockchain, in general, is a bit more complicated and will be explained further down. The benefits and drawbacks of the variations of blockchains that exists will also be explained, focusing on the more popular with the intent on finding what would suit validating documents best. 

\subsection{Bitcoin}

Bitcoin is a digital decentralized currency conceived in a paper by Satoshi Nakamoto\cite{nakamoto2009bitcoin}. Transactions works without an intermediary like a regular bank would do, but rather peer-to-peer. Transactions are validated by nodes that update the blockchain, which is a ledger containing every transaction made. These nodes offer computational power, or CPU cycles to record and verify the transactions in this ledger. This process is called mining, and the nodes are called miners. The reward for verifying and adding to the blockchain is transaction fees for every transaction and the chance to unlock or mine new bitcoins. For every new block in the blockchain that is validated, a set amount of bitcoins is made, and given to the miner who validated the block. This amount is decreasing by 50\% every 4 years or 210 000 solved blocks, and the difficulty of mining is increasing by a total amount of mining power. This is done to regulate the time it should take the network to solve the next block. The goal for a single block should take about 10 minutes to mine.

\subsubsection{Byzantine Fault Tolerance}
The greatest challenge with cryptocurrency up until Bitcoin was Byzantine fault tolerance, and it's still a concern with the bitcoin blockchain. A system that has the characteristics of Byzantine fault tolerance is a system that tolerates or handles a type of failures known as Byzantine Generals' Problem\cite{lamport1982byzantine}. The Byzantine Generals' Problem is best explained with a thought experiment, where Byzantine generals each command their portion of an army. The problem to be solved is how do they decide whether to attack or retreat when all generals must agree on one decision. A partial attack may end in disaster for the attackers, and a gathered attack or retreat would be more effective. The situation is further complicated when the possibility of corrupt generals and messengers arises, and the problems that they would bring.

For example, if there were 5 generals, and two voted for and two voted against, a corrupt general could send a vote to each party. This would result in each half of the army attacking and retreating, thinking that the entire army is doing the same thing.  Messengers could also deliver forged messages or deliver none at all. The Byzantine Generals Problem transfers very well into computer systems, especially distributed systems, where many computers are working together to achieve the same goal. In cryptocurrency, the Byzantine Generals Problem is very important, because most cryptocurrencies is based on a network of computers working together to strengthen the ledger by deciding the order of transactions. There has to be a way of reaching consensus between all of the nodes. Byzantine fault tolerance is achieved when the honest nodes can reach consensus even with the possibility of corrupt nodes. In cryptocurrency, BFT is achieved when at least 51\% of the total computing power is used honestly. This is done through a process called mining.
 
\subsubsection{Mining}\label{subsubsec:mining}

In the beginning, you could mine with your own personal computer, utilizing the CPU and be profitable. Then when more computers were utilized as miners, the difficulty increased so that it was less profitable to just use the CPU. Since mining is  simple hashing of a value, people figured out that graphical processor units, or GPUs, where better suited for mining than CPUs, and so the norm changed to using GPUs, which could produce a much greater rate of hashing. Then came the ASICs, which are dedicated mining machines and can produce even higher hash rates. Present day, miners gather their computational power in collaboration to increase their success rate and sharing the mined bitcoins between every member, based on how much each individual contributed to the group. This is currently is the most profitable way of mining even though the electrical cost is catching up to the profitability of the current ASICs.

BFT in Bitcoin and other proof-of-work cryptocurrencies is achieved by having each node in the network work to solve a hashing problem. The goal is to find the right hash, using the block header and a nonce. This is regulated by the difficulty of the chain, which changes every 2016 blocks, to ensure that it takes about 10 minutes to find each right answer. The right answer is found when the resulting hash of the block header with the nonce is lower than the current difficulty. In more practical terms, since the difficulty is regulated by how many zeroes the hash starts with, needs to have more zeroes in order to be the right proof-of-work.

The difficulty is a 256-bit number shared by the entire network, used for regulating how hard it is for miners to solve new blocks. It is calculated by dividing the easiest possible difficulty by the target difficulty. Imagine a number generator, generating a random number between 1 and 1000. If the target difficulty is 4, only numbers below 1000/4 will be accepted. In this example, 1000 would be the easiest difficulty, with 100\% success rate. This number is updated every 2016 blocks or every two weeks. The updated difficulty is defined based on the time it took to solve the past 2016 blocks. If solving the blocks took less time than expected, the difficulty will be increased by lowering the difficulty number. If the network used more than the expected time to solve the blocks, the number will be increased. Same goes for cryptocurrency mining. A block is not going to be accepted by the network if the hashed block header has a higher value than the difficulty number. 

\begin{figure}[h!]
\begin{equation*}
\textrm{DSHA256}(\mathit{data}) = \textrm{SHA256}(\textrm{SHA256}(\mathit{data}))
\end{equation*}
\begin{equation*}
\textrm{DSHA256}(\mathit{blockheader}) < \mathit{difficulty}
\end{equation*}
\caption{Proof-of-work goal}
\end{figure}

Once a hash with a lower value than the difficulty is found, the miner broadcasts this to the network. The neighbors can easily check if the answer is correct by hashing the nonce that was received and the block header. If the nonce appears to be correct, they will broadcast it to their neighbors again and drop their own mining to continue on a new block on top of the recently discovered one. This process will continue till the entire network knows of the new block. There can be more than one right answer so if two miners solve a block at the same time, forks will be created and worked on till one of the forks has solved more blocks than the competitor. The losers fork will then by annulled and dropped, along with any currency that was received from mining on the losing fork. This way BFT is maintained as long as the majority of nodes are honest.

This method of validating transactions is called proof of work, and uses computational power in exchange for currency, is widely used in other cryptocurrencies as well as Bitcoin. Other proofs, or methods of validating transactions without a central bank or intermediary, has emerged since Bitcoin went public and became popular. Proof of stake, proof of burn, and proof of activity is examples of a few. These use different  types of approaches to validating and keeping track of transactions. Proof of stake needs miners to prove their ownership of their share in the currency. Peercoin, which implements proof-of-stake, uses coin age, or how long the coins have been held by a miner to increase chances of successfully validate the transaction ledger. Proof of burn requires miners to burn or send part of their coins to an unusable address, for validating transactions and unlock new coins. 

\subsubsection{The Blockchain}

The blockchain is by far the most fruitful idea that comes with bitcoin. It's a linked list containing hashed blocks of transactions, linking to each other in a specific order. The hashing makes it very hard to alter anything on the blockchain, due to the fact that it is practically impossible to get the same hash values from different data. An individual or group with the intent of changing something in the blockchain would have to have 51 \% or more of all the computational power currently participating in the blockchain. This way, as long as there are more honest blockchain contributors than dishonest, the chain will not be compromised. If there is a difference in a block, or two blocks get solved at the same time, a fork will happen. This fork will continue till one of the competing chains is longer than the other, and the shortest will be annulled and discarded. 

Blocks in the blockchain are the building stone. A block is comprised of a header and a body. The header contains a version number, the hash of the previous block in the chain, a Merkle root of the transactions, the current difficulty, and the nonce. The previous block hash is there to link all the blocks together, so that if someone with ill intent changes something already in the blockchain, the hash values will differ and the nodes will read it as a fork of the main blockchain. Whether or not they work on it, comes down to how fast the different forks advances and solves new blocks. If you had 51 \% of the computational power, you could make a change and everyone would work on your fork because you would win every race against competing forks.

The Merkle root\cite{merkle} is a tree structure where the parents value is a hash of its children. So, to check if two competing blocks are different, you would only have to check the Merkle root hash. The current difficulty of the blockchain is the number of zeroes at the start of the hash. A nonce is a cryptographic term for a word or number used only once. This is the answer to the proof of work. The body contains all the transactions to be stored. These transactions are hashed only indirectly through the Merkle root. Because of this, a block takes the same time to hash its transactions, independently of the number of transactions. This also makes it easy to browse every transaction ever made, using a hex editor.
 


\subsection{Transactions}

The transactions are the biggest part of a block. Here every transaction ever made in the cryptocurrency is stored and fully browsable. A transaction is a transfer of a set value currency that is broadcast to the network of nodes, or miners. The Bitcoin network is made based on best effort, meaning that there is no certainty that a transaction is picked up by a miner and put into a block. Instead of forcing miners to pick up every transaction, there is a transaction fee that goes to the miner when a block is mined. This fee is completely optional but advised. A miner has no incentive to pick up a transaction without a transaction fee, other than to fill up a block. Choosing to pay a higher transaction fee will make miners want to pick up the transaction and will be confirmed in a block sooner. 

In the Bitcoin network, there are no Bitcoins, either physically or in a digital file. There is only the ledger of transactions, that when summed up gives the current value to each wallet. A bitcoin wallet is just an address to send and receive the currency to. The address is comprised of 26 to 35 alphanumerical characters beginning with the number 1 or 3, depending on what type of wallet it is. Each wallet, or address, has a public key and a private key. The private key is created using secp256k1\cite{sigalg} and is a 256-bit string of random data. A copy of the private key is then deterministically transformed into a secp256k1 public key. The public key can be repeatedly generated at a later time, so there is no need for it to be stored. 

The public key is then hashed and encoded as bitcoin addresses. The hashing of the public key is done to obfuscate it, and make it impossible to decipher the private key from it. Any users with the public address can send bitcoins to the address, using transaction scripts, by decoding the bitcoin address to the public key hash. The private key is used for creating a signature to redeem any potential transactions to the public address. Best practice with transactions and addresses is to generate a new address for each transaction because every transaction is public and browsable. This makes tracking of your transactions virtually impossible. 

\begin{figure}[h!]
\begin{lstlisting}[numbers=none]
Input:
Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b0
  09ca73dd04470b9a6
Index: 0
scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee373
  8d9e1446618c4571d1090db022100e2ac980643b0b82c0e88ffdfec6b6
  4e3e6ba35e7ba5fdd7d5d6cc8d25c6b241501

Output:
Value: 5000000000
scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35549d
OP_EQUALVERIFY OP_CHECKSIG
 \end{lstlisting}
 \caption{Bitcoin Transaction}
 \label{fig:transaction}
\end{figure}

A transaction is built up of a variable number of inputs and outputs. See figure~\ref{fig:transaction}  for an example. Since all bitcoins are just references to earlier transactions, inputs are mostly references to which previous unspent transaction is being spent. There can also be as many inputs as needed, depending on how fragmented your wallet is. The index section of the input of a transaction represents the index of the previous transaction. This is needed because there can also be several outputs to a transaction.

The scriptSig value represents the first half of the transaction script. It contains a public key and a signature. The public key has to match the output hash of the previous transaction from the output script, called scriptPubKey. The signature, combined with the public key, is used to prove that the transaction in question was created by the owner. It is a secp256k1 signature over a hash of a simplified version of the transaction. 

The output section of a transaction contains a value and the second part of the script. The value is the amount of bitcoin that is being transferred, measured in satoshis. A Satoshi is the smallest unit of a bitcoin, worth one hundred millionth of a bitcoin. In the example figure, the amount that is transferred is 50 bitcoins. The script part of the output is called scriptPubKey. This contains the different steps to redeem the transaction by the receiver. This involves checking if the receivers signature matches with the public address in the transaction. 

There are two main types of transactions, Pay-to-PubkeyHash and Pay-to-Script-Hash. These will be referred to with the abbreviations P2PKH and P2SH. P2PKH is the simpler one, and used for transactions to one or multiple bitcoin addresses, and requires only proof that the recipient has control over the private key that corresponding to the hashed public key. This is done with a signature script that checks if hashing the full unhashed public key of the recipient corresponds to the hashed public key hash sent by the sender.

P2SH is made with the intent of creating more complicated transactions. It allows setting of more conditions for the transaction to be spent. This is implemented by instead of using a hash of the public key, a script with the conditions is hashed and encoded to a standard bitcoin address, with one change from P2PKH. The address starts with the number 3, instead of the number 1, which describes a P2PKH address. 
\subsection{Different Blockchains}

The popularity and, therefore, the worth of Bitcoin has significantly increased since its introduction in 2008. Since it's controlled purely by supply and demand, the increased popularity has made the worth of a bitcoin gone from just a theoretical currency to a multi-billion dollar trade, where the price of a single bitcoin has been as high as 1000 USD. After the bankruptcy of Mt. Gox, a bitcoin exchange handling about 70 \% of all transactions, where several hundred thousands of customers bitcoin were lost or stolen, the bitcoin took quite a hit and hit the bottom at about 20 \% of what the value once was. Since then, the price has been steadily increasing again, and at the present time is about 450 USD. With this increase in popularity, the cost of mining will surely continue to increase, and the need for cheaper alternatives to proof of work, or, at least, alterations.  

This design has grown in popularity also outside the cryptocurrency field, because of its ability to store something publicly without revealing what the data is. Industries which are researching ways to utilize the blockchain include, but not limited to, banks, stock exchange, document signing, realty, cloud storage, and much more. 

The original blockchain uses proof-of-work to validate transactions, by making a node spend computational power in exchange for the chance of mining a block. Bitcoin utilizes the Hashcash\cite{hashcash} proof-of-work system which works by hashing a base string and a nonce together, changing the nonce for each try until the resulting hash is lower than the difficulty. An easier way to explain this is to count the number of zeroes a hash starts with. The more zeroes, the lower the value, the more difficult it becomes to get. Because of the randomness that is SHA-256 hashing, it is almost totally random who will solve the proof-of-work first. Because of Bitcoins popularity, the Bitcoin blockchain has become increasingly difficult to mine. Different suggestions have come up to try and improve or replace this original SHA-256 proof-of-work. 

Litecoin is the second most popular cryptocurrency as of yet. It is, as its name suggest, a lighter currency, compared to Bitcoin. Litecoin still uses proof-of-work as validation but has made changes to overcome some of Bitcoins problems. Introducing scrypt, Litecoins proof-of-work system, utilizing more memory and makes it easier for normal computers to contribute and still make a profit. It still uses Bitcoins SHA-256, but as a subroutine. One of the drawbacks of scrypt is because it is easier for regular computers to mine, it is also more at risk for botnet exploitation or attacks. Big enough botnets have a greater chance of double-spending on a blockchain using scrypt than Bitcoins SHA-256 proof-of-work.

Moving away from proof-of-work, there are several other proof-of-x with different benefits and drawbacks. Proof-of-stake, first proposed on an online forum by a user named Quantum Mechanic, uses the currency itself as a stake to mining a new block. The way it works is by proving ownership of currency, and in return, there is a chance to mine the next block. The more currency is held, the greater probability to unlock more. This is one of the big drawbacks with proof-of-stake, where the rich becomes richer. There are several implemented solutions to this, using randomization, coin age or movement. The most popular implementation of proof-of-stake is Peercoin, which utilizes randomization and coin age to achieve consensus. The probability of mining a block is calculated from the amount of coin, and how long the coin has remained in the specific wallet. Coins become able to compete for a block after 30 days, and will continue to increase in probability until it has gone 90 days when the probability reaches a maximum value. Implementations based on movement rewards coins that in exchanged more, with a higher probability of finding the next block. 

One of proof-of-stake's biggest advantages and drawbacks is the cost. Because the currency is also the means of mining, there is little at stake outside the currency. Bitcoin mining uses on average 240kWh per bitcoin, which is a considerable cost when you factor in the purchase cost of the ASICs that do the mining. The International Energy Agency states that for each megawatt(MW) of power spent, results in 650kg of CO2 released into the atmosphere. This means that for every bitcoin mined, 156kg CO2 is released. A proof-of-stake blockchain does not have this problem, but that also means that it is cheaper to exploit, by mining several forks at once. To combat this, Etherum, which is a blockchain for app development, suggested a system where you could punish anyone who was mining several blockchains by making them double sign. This was never implemented because Etherum went with proof-of-work. 

Because of the expense of proof-of-work, there is always incentive to find an alternative, preferably with lower cost and greater security. In the years following the phenomenon of Bitcoin and cryptocurrency, from being a pretty much worthless number on your screen, to its now total multi-billion dollar worth, other big institutions have noticed the potential of the blockchain. Recent years there has been a great increase in ways of using the blockchain, not only for currency and exchanges but for all kinds of areas needing a ledger.

R3 is a company that is currently developing ways to implement the distributed ledger that is the blockchain, into banking and stock markets. It has gained enormous support from the industry and is currently being backed by most of the world's biggest banks and financial institutions. The distributed ledgers that they are creating, are not the open public blockchain that everyone can contribute to as known from cryptocurrency. Instead, they are building it to be a consortium blockchain, which instead of proof-of-work to mine a new block, will require signatures from all of the members of the consortium. The incentive to keep nodes honest doesn't matter in this case because every node is confirmed honest, there is no point in proving that the work has been done. In this manner, institutions can have a distributed ledger which is virtually tamper proof. 


\section{Design and Architecture}

In this section, we will go over each part of the blockchain validation system. The blockchain will feature centralized management allowing more control of what goes into the blockchain compared to other decentralized systems.

\subsection{The Blockchain}
The main component here is the blockchain. Each block is built on the previous such that any change to an earlier block will invalidate any block that comes after it. A good example of this is Git which is a distributed version control system. Each change that is committed is hashed using SHA1 and put at the end of the chain, or branch in the case of Git. The block, called a commit, consists of the changes made as well as metadata like the author, but what's most important is that it contains the SHA1-hash of the previous commit. This SHA1-hash serves as the commit's signature identifying it. So, if the previous commit has changed in some way that would alter it's hash all commits that come after it would no longer be able to trace their way back to the original commit. These commits would become orphans and with no parents to apply their changes to would become obsolete/invalidated.

% Figure

In Bitcoin, the blockchain is used to ensure ordering of transactions as well as consensus. The consensus is achieved by always following the longest known chain. This creates a problem however although it isn't at least realistically possible to change a block in the middle of the chain it is still possible to start a new chain based on the block before it, this is called a fork. If this fork ever grows longer than the main chain it will take over as the new main chain. This way you could rewrite history as you like. With technology like Git, this is not a problem as forking is even encouraged behavior. Money transaction, on the other hand, you want to be permanent. So to prevent long forks you associate a shared cost with the creation of new blocks. With a high cost, it should become too costly to create a new chain that can compete with the main chain. It should also be more expensive to do the further back in the chain you go. The cost ideally should be spread evenly across chain participants so that no minority can outspend the majority, see section \ref{subsubsec:proofofwork}.

In our project, we seek to take this blockchain technology as used in Bitcoin then generalize the kinds of transactions that can be included in a block. This will create a sort of semi-decentralized database. This database can store standard transactions like money transactions as what Bitcoin does. But it can also store documents, either in their entirety or hashed. This allows documents to retrieved later and can serve as a validation service or permanent storage as the blockchain is ideally supposed to be a never-changing entity. The kinds of documents we are talking about are e.g. the hash of diplomas issued by some educational institutions. Other people can then query a blockchain node about a hash's existence on the blockchain. To verify that the document was indeed issued by the respective institution a signature is added to the transaction unique to that institution. This does, however, imply a public key exist which become the institution's identity. This may be stored e.g. on their websites, however, another possible option is to store it on the blockchain itself. However, to have such a transaction you need a way to ensure that only that institution can make that transaction and no one else can. Otherwise, you may end up with identity theft and the release of false documents onto the blockchain. This is where a flexible list of trusted third parties comes in. They will be responsible for collectively deciding what rules the blockchain will use and by extensions what transactions to include. They would in this case only validate a transaction setting an institution's identity if a physical confirmation has been made. Similar to how certificate authorities work today. More details on this in section \ref{subsec:authority}.


\subsubsection{Proof-of-work}\label{subsubsec:proofofwork}
In Bitcoin, the cost associated with each block is work e.i. processing power. So this is a resource you have to spend to generate a block, but how could you prove you performed this work? In Bitcoin, the processing power comes in the form of finding a hash of the block with a value less than some target value. The block has a special nonce field which is just a value you can change to alter the resulting hash. There is no algorithm for efficiently creating a hash of a particular value so you are left with simple brute-force. However, computing power is directly related to how many different nonce values you can try each second so the probability of finding a block is a function of both time and computing power. This function can be turned on its head and you could say that the probability of whoever solved the block, meaning found a hash lower than the target, has a high probability of having performed a lot of work.

% Consider putting a plot here of proof of work.

Solving a block is a random process. This means that the biggest entity in the network who has the most computing power is not guaranteed to solve the block first compared to if the proof-of-work was based on a linear deterministic process. This way the control of what goes on the chain is controlled why the majority of computing power, even when spread across several entities. With less than majority control, an attacker would have to rely on luck to catch up and outperform the rest. The probability of the attacker decreases exponentially as the blockchain increases. Following Satoshi's own calculations\cite{nakamoto2009bitcoin} an attacker with control over 10\% of the network's computing power would have less than 0.1\% chance of succeeding with his attack after just 5 blocks on top of the one the attacker wishes to change. With control over 40\% of the network, you would need 89 blocks to reach 0.1\% which with Bitcoin's 10-minute interval between blocks is just under 15 hours. This makes it so that in a relatively short amount of time blocks can become very resilient to change and can serve as a proof of validity.

We are using proof-of-work in this project because although we plan to have a sense of central authority that determines what makes a valid block we still need a system to determine what goes onto the chain and make sure it stays on the chain. We will be using Bitcoin's implementation of proof-of-work using double SHA256 to make it easier as we are going to be modifying an already existing Bitcoins implementation. However, other solutions exist and it can be combined with other proof of schemes such as proof-of-stake.

\subsubsection{Merkle Tree}\label{subsubsec:merkle_tree}
A Merkle Tree was originally used by Satoshi for Bitcoin as a mechanism to save disk space. It allowed for a way to verify transactions later without actually storing the transactions themselves, this would free up disk space as transactions are what makes up most of the block size. It involves first hashing all transactions, then take a pair of transactions, concatenating them and hashing the result into a new hash. Repeat taking pairs and hash them until we left with only one. This hash is called the Merkle Root and sits on the top of this hash tree we have built. Due to the dependencies of the hashes as with the blockchain itself any change to a transaction will change the Merkle Root.

% Merkle tree figure.

This is useful as it allows the block header to be of fixed size. This prevents people from gaining an advantage by including fewer transactions in a block when mining. This also abstracts the underlying transaction structure as any transaction is simply treated as an array of bytes for the purpose of hashing. This is useful, especially for us as it does not require us to define all types of transactions beforehand, but also if we keep the block header the same we can use existing mining software or algorithms to mine the new blocks.

\subsection{Blockchain Authority}\label{subsec:authority}

The authority of what goes into the blockchain is decided by a certain percentage of member votes. The list of authoritative members is kept on the blockchain itself and is due to change as new blocks are added. This way new members may be added or removed, but only under the authority of already existing members. This will leave a small but flexible number of central members in control over the blockchain. The system works by having each initial authoritative member give a public associated address which would identify him and add this to the initial block in a series of add transactions. Each client would store a list of all public addresses from any add transactions. This membership list would then be further modified by the client as any add/remove transactions were included in new blocks. However, seeing that blocks need a certain percentage of votes to be accepted into the chain means that authoritative members could refuse to vote on blocks containing malicious transactions such as a client trying to add himself. These votes come in the form of a digital signature that is added to the block. Only if a block has enough signatures should a block be considered valid and processed onto the chain. 

\figMembership{How membership change}{Each block is tied to the previous block and contains a set of transactions. The top row is the blockchain itself. The bottom is the current membership list at that block.}

On Figure \ref{fig:membership} you see an example. The first block, which is referred to as the genesis block, is the first actual block in the chain and is typically hard-coded into the program itself. This block, block 0 here, will contain a set of transactions adding an initial list of members. This block requires no signatures as the previous block, null, starts off with an empty list of members, see (a). When block 0 has been accepted and processed all members from any add transactions will be added to the internal membership list, this would create the initial membership list, see (b). Any blocks from that point on would in this example have to have $\frac{2}{3}$ or greater number of votes from all the members on the membership list to be considered valid. The specific membership list would be the one this block is built on top of. At (c) we see a new block being added that is based on block 0. This block has in its signature field the signatures of both A and B, this makes this block a valid block and it is added to the chain. This block contains the transaction to add D and remove C so the internal membership list is updated. The next block that builds on top of block 1 would have to contain two signatures from either A, B or D.

\subsection{Storing Documents}

There is no limit on the kinds of data you can store on the blockchain. The blockchain e.g. Bitcoin uses, however, are very restricted in what goes into a block and only allow bitcoin transactions. It is still possible however to store a file in the form of a hash. Bitcoin's signature script has an operation called OP\_RETURN which returns up to 40 arbitrary bytes. These bytes would contain the hash of the file you wish to store and can be used later to prove the existence of this file as well as a possible ownership later by verifying transaction ownership the same way Bitcoin verifies bitcoin ownership.

One of the drawbacks of this approach is that you have to pay a miners fee just like any other transaction. Since the miners fee is based on the size of the transaction big transactions such as a whole file, not just the hash, could end up taking up an entire block worth of space and be very expensive to include into a block. You also can't put a lot of extra data together with the block and as such can't create bigger data structures.

Our approach is to allow a set of transactions in each block however instead of being under the assumption that these transactions be under the same format we generalize it. Each transaction in the block can be thought of as simply a set of arbitrary data. In the block header, you would have a list of all the transactions the block contains as well as a type id saying what kind of transaction this is. It is the authoritative members job to allow and disallow transactions based on type. This makes it easier to expand the blockchain with more types of transactions as only a smaller subset of nodes need to be updated to handle this new type. Other non-authoritative members would simply accept blocks with unknown transactions types. This makes the blockchain more flexible in what in can store.

\figBlockTxStructure{Example of transaction abstraction}{Shows a simple structure of the transactions within the block. \#Tx is the number of transaction headers. Each header stores a pointer and a size which says wherein the main data chunk this transaction is located. This allows for variable sized transactions.}

A possible transaction could be storing a diploma for finishing a university degree. It would include either the document itself or a hash of it together with a public address of the recipient of the diploma and a signature belonging to the university which handed the diploma out. This information could be retrieved later and together with the signature serve as proof of the diplomas validity. Other uses could be to timestamp and preserve research papers across research institutions. 

% TODO: Add example of transaction body?
\subsection{RPC}
Bitcoin Core uses a remote procedure call(RPC) interface encoded in JSON for communication. This allows users to access information about the blockchain and execute various administrative tasks. With these RPCs, users can make queries about network and blockchain data, and with our implementation, queries about the different transactions and what diplomas they contain. Remote procedure calls are when a program execute a subroutine in another address space, often on a different computer or a shared network. The executable on the remote computer is coded essentially the same as if the subroutine were local or remote to the executing program. Only small differences distinguish them coding-wise, making it easy to execute a program remotely. Though executing times are orders of magnitude longer when executing an RPC remotely. 

A regular RPC system is build up of two major components, the stub generator and the run-time library\cite{rpc}. A stub-generators job is to automate the packing of arguments and results. This is beneficial to writing the packaging manually where mistakes of erroneous coding could occur. It is also greater chance that the automated code is more optimized than handwritten code and, therefore, has a greater chance of higher performance. The stub generator works by handing over an interface containing each of the functions specified. It will then create a client stub containing the functions, which a client program wanting to use the RPC-service would connect to, in order to make RPCs. 

To a client, the code in the client stub appear as function calls, but the client stub code is responsible for all the work of preparing and sending an RPC. This includes creating the message to be sent to the server, by first creating a buffer of some size and then packing the information about the call needed inside. The message includes the function call with the arguments needed. Processing this is called marshaling of arguments or the serialization of the message. When the call message is made, the client stub sends the message to the server and waits for the reply. The reply contains the return values from the function called. If the return more complex than a single return code, the client stub also needs to unpack the more complex result, known as unmarshalling or deserialization. The last action the client stub takes is sending the finished result back to the client program. 

The stub generator also generates server code. The server stub is waiting for RPC-requests with a thread pool. This way the server can handle multiple simultaneous calls. Several worker threads are used so calls can be processed concurrently. The worker threads take an RPC-request and deserializes it to retrieve information on which function to call and with which arguments. Now the function can be called by the run-time library with the appropriate arguments. The run-time library also handles how the message is sent and other issues like timeouts and fragmentation. RPC-services use unreliable transportation protocols like UDP because it is much more efficient than the more reliable TCP. This is because of TCP works with acknowledges of each message, which would clog up the system by sending two extra messages for each request/response. That is why in RPC acknowledges are handled by the client/server and not the transport protocols. 

JSON-RPC works by sending an inquiry to a server with the JSON-RPC protocol implemented. When it receives a request from a client, it responds to the client and makes it wait for the procedure to complete. This is called a request-response message passing system. The server listens for specific HTTP-POST requests on certain port numbers and uses only the basic access authentication provided with HTTP. However, by default, the RPC service is not accessible to other clients, due to it binding to your servers localhost loopback network interface. This system would provide an interface for controlling and adding to the blockchain easily and quickly, as long as the service is running on the local machine. For remote connection, it is recommended to use tunneling with SSH so that the socket is not exposed any further than localhost. 

\section{Implementation}
In this section, the implementation of the system is explained and discussed. The foundation to the implementation is Bitcoin Core, written in Go. This implementation will focus on three main sections of Bitcoin Core, the underlying transaction structure, the btcd which is the main program, and btcctl which is the RPC-service used for communicating with btcd. 

\subsection{Data Structures}

\subsubsection{Blocks}
In this section we'll look at the internal structure of a block. Here we look at a block as a collection of bytes. It's important to have a well defined block structure as the blocks will be sent over the network and different encoding of blocks will break the system. The hash of the block will also be affected, though the hash isn't of the entire block just the header.

A block is said to be solved when the hash of it is below a certain value. To make a chain out of solved blocks each block must store a reference to the previous block in it as a sort of proof that it was created after it. This information and more is put in block header which makes up the first couple of bytes of every block. The block header has not been changed from the Bitcoin implementation. 

The block header has six fields, see code listing \ref{lst:block_structs}. \emph{Version} is a number that's incremented every time a change to the structure of a block makes it incompatible with earlier versions. \emph{PrevBlock} is the hash of the previous block in the chain. \emph{MerkleRoot} is the combined hash of all the transaction in the block, see section \ref{subsubsec:merkle_tree} for more on Merkle trees. \emph{Timestamp} is the approximate time of block creation and also serves as an additional source of variation for the block hash. \emph{Bits} is the targeted value the block's hash needs to be less than. It's encoded similar to standard IEEE754 floating point numbers with the exception that the signed bit is placed between the exponent and the mantissa instead of at the front. To convert to the target see formula \ref{eq:bits_to_target}. \emph{Nonce} is simply 32 bits of data that's only there to change the hash value of the block. This value is typically incremented during mining until a desired hash is produced and a block is considered solved, see section \ref{subsubsec:mining} for more on mining.

\begin{equation}\label{eq:bits_to_target}
\mathit{target} = (-1^{\mathit{sign}}) \cdot \mathit{mantissa} \cdot 256^{\mathit{exponent-3}}
\end{equation}

After this there is the data chunk which makes up the block payload. This data is divided into smaller chunks called transactions which are put end to end inside the payload. Since transactions are abstracted to only bytes there is no way of discerning the transactions by reading through a byte stream compared e.g. a series of zero-terminated strings. This is why we need transaction headers which can tell us where a transaction is located in the block. It's a simple fixed-sized data structure, that way it can be iterated over easily, that stores the transaction's offset into the data chunk and it's size. The transaction headers are located after the block header, but before the data chunk. 

\begin{lstlisting}[float=h!,caption={Block Structure},label=lst:block_structs]
type BlockHeader struct {
  Version int32
  PrevBlock ShaHash
  MerkleRoot ShaHash
  Timestamp time.Time
  Bits uint32
  Nonce uint32
}

type MsgBlock struct {
  Header       BlockHeader
  Transactions []*MsgTx
}
\end{lstlisting}

\subsubsection{Transactions}
The main transaction structure in the btcd implementation is the MsgTx struct in the wire package. Any other transaction struct is just a wrapper around an inner MsgTx such as the Tx struct in the btcutil package. To accommodate the new transaction structure all references to any TxIn or 
TxOut in the old struct were removed and replaced with a single byte slice. This way even unknown transaction formats can be accommodated as they can remain in serialized form indefinitely. To retrieve the underlying transaction in the byte slice a Type field has been added which holds a signed 32-bit integer representing what kind of transaction is in the serialized bytes. Each type may have it's own unique serialization and deserialization method. A interface has been added for making new transaction types easier and serve as a common ground for all transaction such being able to serialize/deserialize themselves. See code listing \ref{lst:transaction_structs}.

\begin{lstlisting}[float=h!,caption={Transaction structure},label=lst:transaction_structs]
type MsgTx struct {
  Type     int32
  LockTime uint32
  Data     []byte
}

// List of transaction types and their numerical equivalent.
const (
  TxTypeUnknown  = -1
  TxTypeData     = 1
  TxTypeFile     = 2
  txTypeSignFile = 3
)

// Go interface for the type stored in MsgTx's Data field.
type TxInterface interface {
  Serialize(w io.Writer) error
  Deserialize(r io.Reader) error
  SerializeSize() int
  GetVersion() int32
  GetType() int32
}
\end{lstlisting}


\subsection{Btcd}
Btcd is the main program of bitcoin. This is the executable which starts the different server parts and connects to the network. 

\subsection{Btcctl}
Btcctl is the part of Bitcoin Core made for communicating with btcd. It uses JSON-RPC for sending and receiving information from the node, blockchain, and network. It is implemented across many files, and this explanation will go over what is needed to add new functions to the btcctl. To use btcctl, username and password are required, as well as a server address with a port number, and of course, the name and arguments of the command to be called. 

\begin{lstlisting}[float=h!,caption={Command handler type},label=lst:cmdHandler]
type commandHandler func(*rpcServer, interface{}, <-chan struct{}) (interface{}, error)
\end{lstlisting}

{\it{rpcserver.go}} is the main server of the RPC-service. Here is where the body of the functions are written and organized. Each of the functions is declared in a map of command handlers and a string representing them. The command handlers take arguments from users using btcctl to issue RPCs. This map of handlers allows the server to pair up the different RPC command strings with the appropriate handler at initialization. It is also here in rpcserver.go that each function is implemented, in the way of a handler, where each callable function is of the type commandHandler. The commandHandler type is a function that takes a pointer to a struct containing all of the server-specific information, an interface which contains the information of the RPC-request, and a channel structure to know it the client closes. The return values are an interface with the results to be sent with RPC back to the client, and an error if there are any.

If arguments are required from the user, they must be registered and declared in another file called {\it{chainsvrcmds.go}}. Here all the JSON-RPC commands supported by the server are housed, and when init() runs it generates the list of command names and arguments. The arguments for each command is declared with a function that takes the arguments from the user and adds it to an interface specified. 


\begin{lstlisting}[float=h!,caption={Command argument formatting},label=lst:cmdArg]
type ExampleCmd struct {
 Example string
}

func NewExampleCmd(ex string) *ExampleCmd {
 return &ExampleCmd{
  Example: ex,
 }
}
\end{lstlisting}

Returns from the RPCs are formatted in a similar fashion in a file called {\it{chainsvrresults.go}}. A struct is declared for each command with complex return values, that is more than a single value. The RPC-service will use this struct to display to the user the results from the request made. 


\section{Result}
Evaluate project. What worked what didn't, etc.

\section{Conclusion}
What to take away/learn from this project.

\newpage
\bibliography{references} 
\bibliographystyle{ieeetr}
\listoffigures

\end{document}