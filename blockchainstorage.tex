\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{float}
\usepackage{titling}
\usepackage[nottoc]{tocbibind}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listings-golang}
\usepackage[font=footnotesize]{caption}
\usepackage{subcaption}
\usepackage{pageslts}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{geometry}

\usetikzlibrary{shapes, arrows, positioning, calc, patterns, decorations.pathreplacing, mindmap,automata, chains, fit}

\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{brblue}{rgb}{0.1,0.4,0.9}
\definecolor{calmblue}{rgb}{0.35,0.6,0.8}
\definecolor{lightgray}{rgb}{0.95,0.95,0.95}

\DeclareCaptionFont{white}{\color{white}\sffamily}
\DeclareCaptionFormat{listing}{\colorbox{calmblue}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% Formatting all lstlisting for go code
\lstset{
    aboveskip=0pt,
    backgroundcolor=\color{lightgray},
    basicstyle={\footnotesize\ttfamily},
    belowcaptionskip=-1pt,
    breakatwhitespace=true,
    breaklines=true,
    columns=flexible,
    commentstyle=\color{dkgreen},
    frame=l,
    keepspaces=true,
    keywordstyle=\color{brblue},
    language=Golang,
    numbers=right,
    numberstyle=\footnotesize\ttfamily\color{gray},
    numbersep=1pt,
    showstringspaces=false, 
    stringstyle=\color{mauve},
    tabsize=4,
    xleftmargin=3.4pt,
    xrightmargin=3.4pt,
}

% Hyphenation rules
\hyphenation{block-chain}

\graphicspath{ {./graphics/} }

% \figMembership defined in this file.
% \figBlockTxStructure defined in this file.
\input{figures.tex}

%\setcounter{page}{1}
\title{Public Blockchain Database with Flexible Ownership}
\author{Kenneth Susort \and Christer Jensen}
\date{\today}

\setlength{\parindent}{3em}
\setlength{\parskip}{1em}

\begin{document}
\pagenumbering{arabic}

\begin{titlepage}
 \begin{center}
  
  \huge
  \textbf{\thetitle}
  
  \vspace{1.5cm}
  
  \textbf{\large\theauthor}
  
  \vfill
  
  {\Large A thesis presented for the degree of\\
  Bachelor in Computer Science}
  
  \vspace{0.8cm}
  
  \includegraphics[width=0.2\textwidth]{university_logo.png}\\
  \large
  IDE\\
  University of Stavanger\\
  Norway\\
  \thedate
  
 \end{center}
\end{titlepage}

\pagenumbering{roman}

\begin{center}
 \vspace*{4cm}
 \textbf{\textit{Abstract}}
\end{center}

This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes.
\newpage

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{\theCurrentPage}

\section{Introduction}

Blockchain is a technology which is used in different types of cryptocurrencies. Cryptocurrency is a medium of exchange or currency and is entirely digital. It is made possible by utilizing certain principles of cryptography to secure transactions and to control the creation of new coins put in circulation. What makes cryptocurrency different from the normal banking system is how the currency is controlled. Regular banking systems use centralized control, where the banks are in control over how much new money is added and at what rate. Cryptocurrencies uses a decentralized system, which hands over control of the currency to its users and contributors. Such a system relies completely on the assumption that there are more honest than dishonest users. Due to this, the more a cryptocurrency grows, the more secure it becomes. 

The popularity and value of Bitcoin has significantly increased since its inception in 2008. Since it's controlled purely by supply and demand, the increased popularity has made Bitcoin go from just a theoretical currency to a multi-billion dollar trade, where the price of a single bitcoin has been as high as 1000 USD. After the bankruptcy of Mt. Gox, a bitcoin exchange handling about 70 \% of all transactions, where several hundred thousands of customer's bitcoin were lost or stolen, the bitcoin took quite a beating and hit the bottom at about 20 \% of what the value it once had. Since then, the price has been steadily increasing again, and at the present time is about 450 USD. With this increase in popularity, the cost of mining will surely continue to increase, as well as the need for better alternatives to proof-of-work.

Industries which are researching ways to utilize the blockchain include, but not limited to, banks, stock exchange, document signing, real estate, cloud storage, and more. 

\section{Background}
% TODO: Elaborate a bit better
The background section explains what the blockchain is, and what purpose the blockchain serves.What the different aspects and developments of cryptocurrency and the blockchain. The benefits and drawbacks of the variations of blockchains that exists will also be explained. 

\subsection{Bitcoin}

Bitcoin is a digital decentralized currency conceived in a paper by Satoshi Nakamoto\cite{nakamoto2009bitcoin}. Transactions works without an intermediary like a regular bank would do, but rather peer-to-peer. Transactions are validated by nodes that update the blockchain. The blockchain is a public ledger containing every transaction made. These nodes offer computational power to record and verify the transactions in this ledger. This process is called mining, and the nodes are called miners. The reward for mining a block and adding it to the blockchain is the transaction fees for every transaction and a variable amount of new bitcoins. The amount of new bitcoins is cut in half every 210 000 blocks (approx. 4 years).

\subsubsection{Byzantine Fault Tolerance}

A system that has the characteristics of Byzantine fault tolerance (BFT) is a system that tolerate or handle a type of failures known as Byzantine failures \cite{lamport1982byzantine}. The Byzantine Generals' Problem is where Byzantine generals each command their own portion of an army. How can we be sure all generals agree on what action to do next? A partial attack may end in disaster for the attackers, and a gathered attack or retreat would be more effective.

Example of the generals problem. If there were 5 generals and two voted for attacking and two voted against attacking, a corrupt general could send both parties a vote supporting their side, resulting in both parties thinking everyone is on the same plan to either attack or flee. This would result in each half of the army attacking and retreating, thinking that the entire army is doing the same thing.  Messengers could also deliver forged messages or deliver none at all. The Byzantine Generals Problem applies very well to computer systems, especially distributed systems where many computers are working together to achieve a common goal. In Bitcoin Byzantine fault tolerance is achieved when the honest nodes can reach consensus even with the possibility of corrupt nodes. This is achieved when at least 51\% of the total computing power belong to honest nodes\cite{nakamoto2009bitcoin}. This is why mining and the blockchain are important concepts. It's the mechanisms through which all participating nodes reach concesus.
 
\subsubsection{Mining}\label{subsubsec:mining}
% TODO: Merge mining and proof-of-work

When Bitcoin was first deployed all mining would be done on personal computers utilizing only the CPU. As more computers were used to mine the difficulty increased and it became less profitable to just use the CPU. Since mining is all about trying as many possibilities as fast as possible it lends itself well to parallel computing. This is why GPUs took over for mining as it drastically outperformed any single CPU. Later we have ASICs, which are sepcial purpose dedicated mining machines built specifically to mine bitcoin. ASICs is what used by present day miners and outperformes both the CPU and GPU by a large margin. Most if not all present day miners collaborate by gathering their computational power in what is called mining pools. This is to minimize risk as any rewards are collected and distributed to all pool participated typically based on the amount of computing power contributed. 

BFT in Bitcoin and other proof-of-work cryptocurrencies is achieved by having each node in the network solve a hashing problem. The difficulty of this problem is adjusted every 2016 blocks to ensure that it takes about 10 minutes to find each solution. It however never changed by more than a factor of four\cite{tschorsch2015bitcoin}.

The difficulty is a number shared by the entire network, used for regulating how hard it is for miners to solve new blocks. It is calculated by dividing the easiest possible difficulty by the target difficulty. Imagine a number generator, generating a random number between 1 and 1000. If the target difficulty is 4, only numbers below 1000/4 will be accepted. In this example, 1000 would be the easiest difficulty, with 100\% success rate. This number is updated every 2016 blocks (about every two weeks). The updated difficulty is defined based on the time it took to solve the past 2016 blocks. 

\begin{figure}[h!]
\begin{equation*}
\textrm{DSHA256}(\mathit{data}) = \textrm{SHA256}(\textrm{SHA256}(\mathit{data}))
\end{equation*}
\begin{equation*}
\textrm{DSHA256}(\mathit{blockheader}) < \mathit{target}
\end{equation*}
\caption{Proof-of-work goal}
\end{figure}

Once a hash with a lower value than the target is found the miner broadcasts this to the network. The neighboring nodes can easily check if the answer is correct by hashing the nonce that was received and the block header. If the nonce appears to be correct, they will broadcast it to their neighbors again and drop their own mining to continue on a new block on top of the recently discovered one. This process will continue till the entire network knows of the new block. There can be more than one solution so if two miners solve a block at the same time, forks will be created and worked on till one of the forks has solved more blocks than the competitor. The losers fork will then by annulled and dropped, along with any currency that was received from mining on the losing fork. This way BFT is maintained as long as the majority of nodes are honest.

Transactions are validated through proof-of-work and is used in other cryptocurrencies. Other methods of validating transactions without a central bank or intermediary has emerged since Bitcoin went public and became popular. Proof-of-stake, proof-of-burn, and proof-of-activity is examples of a few. These use different types of approaches to validating and keeping track of transactions. Peercoin which is implemented with proof-of-stake uses coin age, e.i. how long the coins have been held by a miner, to increase chances of successfully validate the transaction ledger. Proof-of-burn requires miners to burn or send part of their coins to an unusable address, for validating transactions and unlock new coins. 

\subsubsection{Proof-of-work}\label{subsubsec:proofofwork}

In Bitcoin the cost associated with each block is work, i.e. processing power. So this is a resource you have to spend to generate a block, but how could you prove you performed this work? In Bitcoin the processing power comes in the form of finding a hash of the block with a value less than some target value. The block has a special nonce field which is just a value you can change to alter the resulting hash. There is no algorithm for efficiently creating a hash of a particular value so you are left with simple brute-force. However, computing power is directly related to how many different nonce values you can try each second so the probability of finding a block is a function of both time and computing power. This function can be turned on its head and you could say that the probability of whoever solved the block, meaning found a hash lower than the target, has a high probability of having performed a lot of work.

% Consider putting a plot here of proof-of-work.

Solving a block is a random process. This means that the biggest entity in the network who has the most computing power is not guaranteed to solve the block first compared to if the proof-of-work was based on a linear deterministic process. This way the control of what goes on the chain is controlled by the majority of computing power, even when spread across several entities. With less than majority control, an attacker would have to rely on luck to catch up and outperform the rest. The probability of the attacker decreases exponentially as the blockchain increases. Following Satoshi's own calculations\cite{nakamoto2009bitcoin} an attacker with control over 10\% of the network's computing power would have less than 0.1\% chance of succeeding with his attack after just 5 blocks on top of the one the attacker wishes to change. With control over 40\% of the network, you would need 89 blocks to reach 0.1\% which with Bitcoin's 10-minute interval between blocks is just under 15 hours. This makes it so that in a relatively short amount of time blocks can become very resilient to change and can serve as a proof of validity.

\subsubsection{The Blockchain} % TODO: Clean-up

The blockchain is at the core of what makes up Bitcoin. The blockchain a linked list containing blocks of transactions linked to each other in a specific order. The hashing makes it very hard to alter anything on the blockchain, due to the fact that it is practically impossible to get the same hash values from different data. An individual or group with the intent of changing something in the blockchain would have to have 51 \% or more of all the computational power currently participating in the blockchain. This way, as long as there are more honest blockchain contributors than dishonest, the chain will not be compromised. If two blocks get solved at the same time a fork will happen. % TODO: Explain more about forks any and races.

A block is comprised of a header and a body. The header contains a version number, the hash of the previous block in the chain, a Merkle root of the transactions, the current difficulty, and the nonce. The previous block hash is there to link all the blocks together, so that if someone with ill intent changes something already in the blockchain, the hash values will differ and the nodes will read it as a fork of the main blockchain. Whether or not they work on it, comes down to how fast the different forks advances and solves new blocks. If you had 51 \% of the computational power, you could make a change and everyone would work on your fork because you would win every race against competing forks.

Each block is built on the previous such that any change to an earlier block will invalidate any block that comes after it. A good example of this is Git which is a distributed version control system. Each change that is committed is hashed using SHA1 and put at the end of the chain, or branch in the case of Git. The block, called a commit, consists of the changes made as well as metadata like the author, but what's most important is that it contains the SHA1-hash of the previous commit. This SHA1-hash serves as the commit's signature identifying it. So, if the previous commit has changed in some way that would alter it's hash all commits that come after it would no longer be able to trace their way back to the original commit. These commits would become orphans and with no parents to apply their changes to would become obsolete/invalidated.

% TODO: Figure

In Bitcoin, the blockchain is used to ensure consensus on the order of transactions. The consensus is achieved by always following the longest known chain. This creates a problem however, although it isn't at least realistically possible to change a block in the middle of the chain, it is still possible to start a new chain based on the block before it, this is called a fork. If this fork ever grows longer than the main chain it will take over as the new main chain. This way you could rewrite history as you like. With technology like Git, this is not a problem as forking is even encouraged behavior. Money transaction, on the other hand, you want to be permanent. So to prevent long forks you associate a shared cost with the creation of new blocks. With a high cost, it should become too costly to create a new chain that can compete with the main chain. It should also be more expensive to do the further back in the chain you go. The cost ideally should be spread evenly across chain participants so that no minority can outspend the majority, see section \ref{subsubsec:proofofwork}.


\subsubsection{Merkle Tree}\label{subsubsec:merkle_tree}

A Merkle Tree was used by Satoshi for Bitcoin as a way to save disk space. It allowed for a way to verify new transactions later without actually needing storing the transactions themselves, this would free up disk space as transactions are what makes up most of the block size. It involves first hashing all transactions. Then taking a pair of transactions hashes and concatenating them together. Lastly hashing the result into a new hash. Repeat taking pairs and hash them until we are left with only one hash. This hash is called the Merkle Root and is the topmost node in the tree. Due to the dependencies of the hashes as with the blockchain itself any change to a transaction will change the Merkle Root. See figure \ref{fig:basic_merkle_tree} for example.

\figMerkleTree{Basic Merkle Tree}{The plus symbol here represent basic string concatination.}

This is useful as it allows the block header to be of fixed size. This also abstracts the underlying transaction structure as any transaction is simply treated as an array of bytes for the purpose of hashing. This is useful, especially for our project as it does not require us to define all types of transactions beforehand, but also if we keep the block header the same we can use existing mining software or algorithms to mine the new blocks.


\subsection{Transactions}

The transactions are the biggest part of a block. Here every transaction ever made in the cryptocurrency is stored and fully browsable. A bitcoin transaction is a transfer of a set value currency that is broadcast to the network of nodes, or miners. The Bitcoin network is made based on best effort, meaning that there is no guarantee that a transaction is picked up by a miner and put into a block. Instead of forcing miners to include every transaction, there is a transaction fee that goes to the miner when a block is mined. This fee is completely optional but advised. A miner has no incentive to include a transaction without a transaction fee, other than to fill up a block. Choosing to pay a higher transaction fee will make miners want to include the transaction and will be confirmed in a block sooner. 

In the Bitcoin network, there are no bitcoins, either physically or in a digital file. There is only the ledger of transactions, that when summed up gives the current value to each wallet. A bitcoin wallet is just an address to send and receive the currency to. The address is comprised of 26 to 35 alphanumerical characters beginning with the number 1 or 3, depending on what type of wallet it is. Each wallet, or address, has a public key and a private key. The private key is created using secp256k1\cite{sigalg} and is a 256-bit string of random data. The private key is then used to generate its corresponding secp256k1 public key. The public key can be repeatedly generated at a later time, so there is no need for it to be stored. 

The public key is then hashed and encoded to a bitcoin addresses. The hashing of the public key is done to obfuscate it, and make it impossible to decipher the private key from it. Any users with the public address can send bitcoins to the address, using transaction scripts, by decoding the bitcoin address to the public key hash. The private key is used for creating a signature to redeem any potential transactions to the public address. Best practice with transactions and addresses is to generate a new address for each transaction because every transaction is public and browsable. This makes tracking of your transactions quite difficult, although not impossible\cite{meiklejohn2013fistful}. 

\begin{figure}[h!]
\begin{lstlisting}[numbers=none]
Input:
Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b0
  09ca73dd04470b9a6
Index: 0
scriptSig: <sig> <pubKey>

Output:
Value: 5000000000
scriptPubKey: OP_DUP OP_HASH160 <pubKeyHash>
OP_EQUALVERIFY OP_CHECKSIG
 \end{lstlisting}
 \caption{P2PKH Transaction}
 \label{fig:transaction}
\end{figure}

A transaction is built up of a variable number of inputs and outputs. See figure \ref{fig:transaction} for an example. Since all bitcoins are just references to earlier transactions, inputs are references to which previous unspent transaction is being spent. There can also be as many inputs as needed, depending on how fragmented your wallet is. The index section of the input represents the index of the output in the previous transaction. This is needed because there can also be several outputs to a transaction. In the example the output specifies a value of 50 bitcoin (BTC) is being sent from a single previous transaction. Based on the index value of 0, the 50 BTC were the first output of that transaction. 

The scriptSig value represents the first half of the transaction script. It contains a public key and a signature. The public key has to match the output hash of the previous transaction from the output script, called scriptPubKey. The signature, combined with the public key, is used to prove that the transaction in question was created by the owner. It is a secp256k1 signature over a hash of a simplified version of the transaction. 

The output section of a transaction contains a value and the second part of the script. The value is the amount of bitcoin that is being transferred, measured in satoshis. A Satoshi is the smallest unit of a bitcoin, worth one hundred millionth of a bitcoin. In the example figure, the amount that is transferred is 50 bitcoins. The script part of the output is called scriptPubKey. This contains the different steps to validate and redeem the transaction by the receiver. This involves checking if the receiver's signature matches with the public address in the transaction. 

There are two main types of transactions, Pay-to-PubkeyHash and Pay-to-Script-Hash. These will be referred to with the abbreviations P2PKH and P2SH. P2PKH is the simpler one, and used for transactions to one or multiple bitcoin addresses. It requires only proof that the recipient has control over the private key that corresponding to the hashed public key. This is done with a signature script that checks if hashing the full unhashed public key of the recipient corresponds to the hashed public key hash sent by the sender. Figure \ref{fig:transaction} is an example of a P2PKH transaction. 

\begin{figure}[h!]
\begin{lstlisting}[numbers=none]
scriptPubKey: OP_HASH160 <scriptHash> OP_EQUAL 
scriptSig: ..signatures... <serialized script>
 \end{lstlisting}
 \caption{Script Section of a P2SH Transaction}
 \label{fig:transaction2}
\end{figure}

P2SH is made with the intent of creating more complicated transactions. It allows setting or more conditions for the transaction to be spent. This is implemented by using a script with the conditions, rather than the hashed public key. Seen in figure \ref{fig:transaction2}, the P2SH transaction is much more versatile than the standard P2PKH. The more open format places no limitations on the script and hence can be formed at the will of the sender. The script is then hashed and encoded to a standard bitcoin address, with one change from P2PKH. The address starts with the number 3, instead of the number 1, which describes a P2PKH address. 

\subsection{Elliptic Curve Digital Signature Algorithm}
The bitcoin blockchain uses Elliptic Curve Digital Signature Algorithm (ECDSA). ECDSA is done in two phases, verifying the public and private key of the client. If both are verified, the client is considered real. ECDSA is a signed verifier procedure and the name describes what it does, which is signing a message with a trusted signer, and using that to verify the integrity of the message and the identity of the sender. The E and C in ECDSA refers to elliptical curve cryptography (ECC), which is a modern and very strong encryption algorithm. The highly sophisticated mathematics behind ECC means that ECC does not require a long key like some of the older standards, such as RSA. The shorter key length helps make ECC about ten times faster than RSA\cite{jansma2004performance} at present time. 

Phase one of the process starts with the certificate stored in the client. The host requests the certificate from the client. Once the host receives the certificate, it unpacks the certificate into the certificate data, the signature and the client's public key. It then digests the certificate data by running it through a hash function to create a 32 byte digest in accordance with X.509 procedures. The X.509 is an important standard in the Transport Layer Security protocol used to manage digital certificates. ECDSA is then run in the host to verify the clients public key using three inputs, the public key of the host, the digest of the certificate data and the signature that was sent over with the certificate. Once the ECDSA processes run, we can go to phase two. If, however, the processes finds that the public key is not verified, the ECDSA process stops here.

Phase two is to verify the clients private key. The host sends a random challenge to the client, to create the signature. The client uses the clients private key and runs the signature engine. The ECDSA signature engine of course, uses the ECC algorithm. The new signature is sent to the host, and used as an input to run the ECDSA verifing calculating using that signature, the clients public key that was verified in phase one, and the the very same random challenge that was used to create the signature in the client. If it passes, then the client is considered as real. 

\subsection{Alternative Blockchains}\label{subsec:difblocks}
Because of the enormous growth of Bitcoin and the following difficulty of mining, it becomes harder and more expensive to operate for the average person. Around the time when Bitcoin became popular, other blockchains started appearing with their own differences and advantages. These differences ranged from small changes, such as the time it took to mine, to more fundamental ones. People started seeing other uses for the blockchain, and adapting it to their own purposes. 

The Bitcoin blockchain uses proof-of-work to validate transactions, by making a node spend computational power in exchange for the chance of mining a block. Bitcoin utilizes the Hashcash\cite{hashcash} proof-of-work system which works by hashing a base string and a nonce together, changing the nonce for each try until the resulting hash is lower than the difficulty. Because of the randomness that is SHA-256 hashing, it is almost totally random who will solve the proof-of-work first. Because of Bitcoins popularity, the Bitcoin blockchain has become increasingly difficult to mine. Different suggestions have come up to try and improve or replace this original SHA-256 proof-of-work. 

Litecoin is another very popular cryptocurrency. It is as its name suggest a lighter currency compared to Bitcoin. The biggest change is a replacing of Bitcoins SHA-256 with scrypt. Litecoins proof-of-work system utilizes less raw CPU cycles and favours more memory making it easier for normal computers to contribute and still make a profit\cite{ahamad2013survey}. It still uses SHA-256, but as a subroutine. One of the drawbacks of scrypt is that because it is easier for regular computers to mine, it is also more at risk for botnet exploitation or attacks. Big enough botnets have a greater chance of double-spending on a blockchain using scrypt than Bitcoin's SHA-256 proof-of-work. Litecoin has also a faster block generation, with a target block time of only 2.5 minutes compared to Bitcoins 10 minutes block generation time. This allows Litecoin to handle a greater volume of transactions, but it also means that the blockchain grows faster, creating more orphaned blocks. The faster generation times also makes double spending harder( not including botnets) and real world usage easier, due to lesser confirmation time. 

Moving away from proof-of-work, there are several other proof-of-x schemes with different benefits and drawbacks. Proof-of-stake, first proposed on an online forum by a user named QuantumMechanic, uses the currency itself as a stake to mining a new block\cite{proofofstake}. The way it works is by proving ownership of currency, and in return, there is a chance to mine the next block. The more currency that is held, the greater probability to unlock more. This is one of the big drawbacks with proof-of-stake, where the rich becomes richer. There are several implemented solutions to this, using randomization, coin age or movement. The most popular implementation of proof-of-stake is Peercoin, which utilizes randomization and coin age to achieve consensus\cite{croteau2014proof}. The probability of mining a block is calculated from the amount of coins, and how long the coins have remained in the specific wallet. Coins become able to compete for a block after 30 days, and will continue to increase in probability until it has gone 90 days when the probability reaches a maximum value. Implementations of proof-of-stake based on movement, are rewarding coins that are exchanged more, with a higher probability of finding the next block. 

One of proof-of-stake's biggest drawbacks is the cost. Because the currency is also the means of mining there is little at stake outside the currency. Bitcoin mining uses on average 240 kWh per bitcoin which is a considerable cost when you factor in the purchase cost of the ASICs that do the mining. The International Energy Agency states that for each megawatt of power spent results in 650 kg of $CO_2$ released into the atmosphere. This means that for every bitcoin mined 156 kg $CO_2$ is released. A proof-of-stake blockchain does not have this problem, but that also means that it is cheaper to exploit by mining several forks at once. To combat this Etherum, which is a blockchain for app development, suggested a system where you could punish anyone who was mining several blockchains by making them double sign. This was never implemented because Etherum went with proof-of-work. 

Because of the expense of proof-of-work there is always incentive to find an alternative, preferably with lower cost and greater security. In the years following the phenomenon of Bitcoin and cryptocurrency from being a pretty much worthless number on your screen to its now total multi-billion dollar worth, other big institutions have noticed the potential of the blockchain. Recent years there has been a great increase in ways of using the blockchain, not only for currency and exchanges, but for all kinds of areas needing a ledger.

R3 is a company that is currently developing ways to implement the distributed ledger, that is the blockchain, into banking and stock markets. It has gained enormous support from the industry and is currently being backed by most of the world's biggest banks and financial institutions. The distributed ledgers that they are creating, are not the open public blockchain that everyone can contribute to as known from cryptocurrency. Instead, they are building it to be a consortium blockchain, which instead of proof-of-work to mine a new block, will require signatures from all of the members of the consortium. The incentive to keep nodes honest doesn't matter in this case because every node is confirmed honest, there is no point in proving that the work has been done. In this manner, institutions can have a distributed ledger which is virtually tamper proof. The problems with this approach is that without proof-of-work, Bitcoin looses its effectiveness in resolving disputes, and becomes a regular database. A private ledger like the one R3 is developing, has to have a way of resolving disputes in an effective manner, or else the whole point is moot. 

\subsection{Communication}
Bitcoin Core uses a remote procedure call (RPC) interface encoded in JSON for communication. This allows users to access information about the blockchain and execute various administrative tasks. With these RPCs, users can make queries about network and blockchain data, and with our implementation, queries about the different transactions and what diplomas they contain. Remote procedure calls are when a program execute a subroutine in another address space, often on a different computer or a shared network. The executable on the remote computer is coded essentially the same as if the subroutine were local or remote to the executing program. Only small differences distinguish them coding-wise, making it easy to execute a program remotely. Though execution time are orders of magnitude longer when executing an RPC remotely. 

Bitcoin's JSON-RPC works by sending an inquiry to the RPC-server with the JSON-RPC protocol. When starting the Bitcoin program using command line, the -rpclisten:IP:PORT option must be specified for the RPC-server to start. When it receives a request from a client, it responds to the client and makes it wait for the procedure to complete. This is called a request-response message passing system. The server listens for specific HTTP-POST requests on certain port numbers and uses only the basic access authentication provided with HTTP. However, by default, the RPC service is not accessible to other clients, due to it binding to your servers localhost loopback network interface. This system would provide an interface for controlling and adding to the blockchain easily and quickly.

The RPC interface isn't designed to be used in any scenario which would require SSL, which would be access over the internet or other untrusted networks. It doesn't have the necessary denial of service protections or review to make it safe for use this way, and so letting potentially malicious clients connect to it would be incredibly unwise. If you need to talk to a remote btcd instance you are better off tunneling with SSH or stunnel which will provide a secure, authenticated path without exposing the socket any further than localhost. Currently there are no SSL functionality on the Go implementation of Bitcoin. The most interesting thing about using JSON and Go is how well Go handles JSON. Go has a package that deals with JSON marshalling, so making a JSON message is as easy as defining a structure with the values to be sent and just use the marshall and unmarshall functions to change between Go structures and JSON messages. This makes making all the API calls easier and faster.

\section{Design and Architecture}

In this section, we will go over each part of the blockchain validation system. The blockchain will feature centralized management allowing more control of what goes into the blockchain compared to other decentralized systems.

\subsection{The Blockchain}

When choosing a blockchain to branch from, there are a few options to consider. There are a alot of different blockchains to consider, some discussed in Chapter \ref{subsec:difblocks}, and many of them are implemented in several different programming languages. The original implementation of Bitcoin, Bitcoin Core, is written in C++ and is still maintained as an open source project. This is the direct descendant from the implementation Satoshi released after he published his paper on Bitcoin. Because of the age of this implementation, there is the most documentation on it, between the different chains and implementations. The problems with this implementation is the enormous size and its complexity. Bitcoin Core has been in development since 2009, with every part of the node functionality in one huge project. A daunting prospect indeed.

Litecoin was discussed in the background chapter as a potential alternative blockchain for this project. With its faster transaction processing and new scrypt algorithm, and being the second most popular cryptocoin, Litecoin is an interesting alternative to start from. It was created with improvements over Bitcoin in mind, but the higher vulnerability to botnet attacks are a big disadvantage, when this blockchain application is mostly directed towards institutions. The reward aspect of the blockchain is removed as well, removing the reason for private people to help mining it. Because of this removal, mining it should be harder for ordinary people and botnets. Therefore the original SHA-256 is favourable. Litecoin also has faster transaction time, making the prospect of everyday use for smaller transactions, like buying items in a store, more reliable for the vendor. With our intent of file and document storage, transaction processing times aren't that important, because document storing doesn't need to be confirmed as quickly as e.g. buying a coffee at a coffee shop. This blockchain system would not benefit from more blocks either, making the chain longer than necessary. 

Alternative implementations is therefore worthy of consideration, due to their focus on efficiency and developer friendliness. Language differences alone can make a big difference when discussing these implementations. Go has several benefits over C++, like integrated test infrastructure, which makes testing new code easier\cite{davec}. Also, Go has better platform independence, making it easier to run on other operating systems without changing the code, just by specifying the wanted operating system when compiling. The time is takes to compile the bitcoin client is also better, with significant improvements in efficiency. One of the most common security vulnerabilities in C++ is buffer overflow, which Go has no active management over, making it easier to code securely. Though security is important, tools like better documentation facilities and exellent concurrency support also counts in favour of Go. 

Other than language differences, bitcoind(C++ implementation) and btcd(Go implementation)
have several differences even though they implement the same blockchain. Btcd offers a much more modular implementation, where the wallet and several other services are disconnected from the main service. This is a great advantage over bitcoind for this project, due to most of the other modules are not required as we plan to remove the currency and make our own user system. Another advantage that the way btcd is written provides, is the fact that it's a clean refactor of the entire bitcoin protocol, written with the goal of well a commented, easy-to-follow codebase. Bitcoind is infamous for having a lot of undocumented sections, making the code harder to understand. 
%TO BE MERGED IN BACKGROUND {

The main component here is the blockchain. Each block is built on the previous such that any change to an earlier block will invalidate any block that comes after it. A good example of this is Git which is a distributed version control system. Each change that is committed is hashed using SHA1 and put at the end of the chain, or branch in the case of Git. The block, called a commit, consists of the changes made as well as metadata like the author, but what's most important is that it contains the SHA1-hash of the previous commit. This SHA1-hash serves as the commit's signature identifying it. So, if the previous commit has changed in some way that would alter it's hash all commits that come after it would no longer be able to trace their way back to the original commit. These commits would become orphans and with no parents to apply their changes to would become obsolete/invalidated.

% Figure

In Bitcoin, the blockchain is used to ensure consensus on the order of transactions. The consensus is achieved by always following the longest known chain. This creates a problem however, although it isn't at least realistically possible to change a block in the middle of the chain, it is still possible to start a new chain based on the block before it, this is called a fork. If this fork ever grows longer than the main chain it will take over as the new main chain. This way you could rewrite history as you like. With technology like Git, this is not a problem as forking is even encouraged behavior. Money transaction, on the other hand, you want to be permanent. So to prevent long forks you associate a shared cost with the creation of new blocks. With a high cost, it should become too costly to create a new chain that can compete with the main chain. It should also be more expensive to do the further back in the chain you go. The cost ideally should be spread evenly across chain participants so that no minority can outspend the majority, see section \ref{subsubsec:proofofwork}.
 % }
 
In our project, we seek to take this blockchain technology as used in Bitcoin then generalize the kinds of transactions that can be included in a block. This will create a sort of semi-decentralized database. This database can store standard transactions like money transactions, as Bitcoin does. But it can also store documents, either in their entirety or hashed. This allows documents to be retrieved later and can serve as a validation service or permanent storage as the blockchain is ideally supposed to be a never-changing entity. The kinds of documents we are talking about are e.g. the hash of diplomas issued by some educational institutions. Other people can then query a blockchain node about a hash's existence on the blockchain. To verify that the document was indeed issued by the respective institution a signature is |- to the transaction unique to that institution. This does, however, imply a public key exist which become the institution's identity. This may be stored e.g. on their websites.

Another possible option is to store the public key on the blockchain itself. However, to have such a transaction you need a way to ensure that only that institution can make that transaction and no one else can. Otherwise, you may end up with identity theft and the release of false documents onto the blockchain. This is where a flexible list of trusted third parties comes in. They will be responsible for collectively deciding what rules the blockchain will use and by extension what transactions to include. They would in this case only validate a transaction setting an institution's identity if a physical confirmation has been made. Similar to how certificate authorities work today. More details on this in section \ref{subsec:authority}.


% UTVID {
We are using proof-of-work in this project because although we plan to have a sense of central authority that determines what makes a valid block we still need a system to determine what goes onto the chain and make sure it stays on the chain. We will be using Bitcoin's implementation of proof-of-work using double SHA256 to make it easier as we are going to be modifying an already existing Bitcoins implementation. However, other solutions exist and it can be combined with other proof of schemes such as proof-of-stake.
% }

\subsection{Blockchain Authority}\label{subsec:authority}

The authority of what goes into the blockchain is decided by a certain percentage of member votes. The list of authoritative members is kept on the blockchain itself and is due to change as new blocks are added. This way new members may be added or removed, but only under the authority of already existing members. This will leave a small but flexible number of central members in control over the blockchain. The system works by having each initial authoritative member give a public associated address which would identify him and add this to the initial block in a series of add transactions. Each client would store a list of all public addresses from any add transactions. This membership list would then be further modified by the client as any add/remove transactions were included in new blocks. However, seeing that blocks need a certain percentage of votes to be accepted into the chain means that authoritative members could refuse to vote on blocks containing malicious transactions such as a client trying to add himself. These votes come in the form of a digital signature that is added to the block. Only if a block has enough signatures should a block be considered valid and accepted onto the chain. 

\figMembership{How membership change}{Each block is tied to the previous block and contains a set of transactions. The top row is the blockchain itself. The bottom is the current membership list at that block.}

On Figure \ref{fig:membership} we illustrate an example of membership change. The first block, which is referred to as the genesis block, is the first actual block in the chain and is typically hard-coded into the program itself. This block, block 0 here, will contain a set of transactions adding an initial list of members. This block requires no signatures as the previous block, null, starts off with an empty list of members, see (a). When block 0 has been accepted and processed all members from any add transactions will be added to the internal membership list, this would create the initial membership list, see (b). Any blocks from that point on would in this example have to have $\frac{2}{3}$ or greater number of votes from all the members on the membership list to be considered valid. The specific membership list would be the one this block is built on top of. At (c) we see a new block being added that is based on block 0. This block has in its signature field the signatures of both A and B, this makes this block a valid block and it is added to the chain. This block contains the transaction to add D and remove C so the internal membership list is updated. The next block that builds on top of block 1 would have to contain two signatures from either A, B or D.

\subsection{Storing Documents}

In principle, there is no limit on the kinds of data you can store on the blockchain. The blockchain that e.g. Bitcoin uses, however, are very restricted in what goes into a block and only allow bitcoin transactions. It is still possible however to store a file in the form of a hash. Bitcoin's signature script has an operation called OP\_RETURN which returns up to 40 arbitrary bytes. These bytes would contain the hash of the file you wish to store and can be used later to prove the existence of this file as well as a possible ownership later by verifying transaction ownership the same way Bitcoin verifies bitcoin ownership.

One of the drawbacks of this approach is that you have to pay a miners fee just like any other transaction. Since the miners fee is based on the size of the transaction, big transactions such as a whole file, not just the hash, could end up taking up one or more blocks worth of space and be very expensive to include into the blockchain. You also can't put a lot of extra data together with the block and as such can't create bigger data structures.

Our approach is to allow a set of transactions in each block. However, instead of being under the assumption that these transactions are the same format, we generalize it. Each transaction in the block can be thought of as simply a set of arbitrary data. In the block header, you would have a list of all the transactions the block contains as well as a type id saying what kind of transaction this is. It is the authoritative members job to allow and disallow transactions based on type. This makes it easier to expand the blockchain with more types of transactions as only a smaller subset of nodes need to be updated to handle this new type. Other non-authoritative members would simply accept blocks with unknown transactions types. This makes the blockchain more flexible in what in can store.

\figBlockTxStructure{Example of transaction abstraction}{Shows a simple structure of the transactions within the block. \#Tx is the number of transaction headers. Each header stores a pointer and a size which says wherein the main data chunk this transaction is located. This allows for variable sized transactions.}

A possible transaction could be storing a diploma for finishing a university degree. Such a transaction would include either the document itself or a hash of the document together with a public address of the recipient of the diploma and a signature belonging to the university that issued out the diploma. This information could be retrieved later and together with the signature serve as proof of the diplomas validity. Other uses could be to timestamp and preserve research papers across research institutions. 

% TODO: Add example of transaction body?
\subsection{Communicating with a Node}
 
Several key API calls are needed for using and controlling the node of this new blockchain. There is a need for calls regarding the transferral of files. To store or load files from disk, encoding and decoding is required. An uploading function would take a file and the senders key, and encodes it properly into a transaction. On the downloading side, a function is required to decode a transaction containing a file, check its integrity and save it to disk. Go has several options regarding encoding files with  packages like gob and binary. The binary is a package with easy read and write functions, as well as easy encoding and decoding. %% MORE ON DIFFERENT PACKAGES

\subsection{Users}

Verifying that the transaction has not been tampered with in Bitcoin is dealt with by using a signature generated from the key pair of the sender and the transaction itself using the ECDSA. This algorithm can then be used on the receiving side to verify a signature. By parsing the signature along with the transaction it using the Go implementations elliptic curve package, the receiver can extract the public key and generate a verify the signature from the public key and the transaction. In Bitcoin the key pair is stored and handled in the wallet program, but because our blockchain have no currency, we decided it was more effective to create a simpler user system, than to strip and modify the existing wallet structure. A basic user system requires a username and a password to log in, and a private key for signing transactions. Both the password and the private key needs to be protected and kept secret, because with a private key of another user, a corrupt user could sign transactions, posing as the owner of the private key. 

To keep these secret and secure, we decided to not store the password anywhere, but rather the hash of the password using SHA-256. A password checker would take the input password, hash it and compare the hash to the stored hash. This way, even if the attacker had the user file, he would not be able to get the password from what is stored on disk. The private key on the other hand, must be stored in a way that a user can be able to securely retrieve it when logging in with the correct password. Go has a cipher package with different modes of operation. A mode of operation is an algorithm which uses an block cipher to encrypt messages in a way that provides confidentiality\cite{fergusonblock}. A block is just a fixed-length group of bits. Cipher Feedback mode was our pick, because it is oen of the most common mode of operations and therefore more literature about this type of encryption. Using the hashed password as the key to the mode of operation, encrypting the private key to be stored on disk securely. 

\section{Implementation}
In this section we look at the specifics of the implemenation that we came up with. For our project we decided to modifiy an already existing Bitcoin implementation and change it to suit our needs rather than starting from scratch. We were also more familiar with Bitcoin and its usage of the blockchain compared to other open-source alternatives that we could find. More specifically we decided to modify btcd\cite{btcsuite2015} which is full Bitcoin node implementation similar to BitcoinCore except the wallet functionality. There are a lot of depedencies as well as utility programs such as a bitcoin wallet in the btcsuite's other repositories. Btcd comes with certain additional programs such as btcctl which is the RPC-service used for communicating with btcd. 

\subsection{Main Program Flow}
In this section we'll look at the overall structure of btcd, breaking it down to it's individual sub-components. 

\figProgramFlow{Program Flow}{This figure shows btcd's execution and how its different subsystems are started during startup. The light blue nodes are loops that exists for the entire lifetime of the program.}

TODO: How btcd does looping and its use of channels. also add discussion on figure 6.


\subsection{Data Structures}
In this section we look at the key data structures that make up the implementation of btcd. 

\subsubsection{Blocks}
In this section we'll look at the internal structure of a block. Here we look at a block as a collection of bytes. It's important to have a well-defined block structure as the blocks will be sent over the network and different encoding of blocks will break the system. The hash of the block will also be affected, though the hash isn't of the entire block just the header.
% Elaborate on the differences or move to another chapter {
A block is said to be solved when the hash of it is below a certain value. To make a chain out of solved blocks each block must store a reference to the previous block in it as a sort of proof that it was created after it. This information and more is put in block header which makes up the first couple of bytes of every block. The block header has not been changed from the Bitcoin implementation. 

The block header has six fields, see code listing \ref{lst:block_structs}. \emph{Version} is a number that's incremented every time a change to the structure of a block makes it incompatible with earlier versions. \emph{PrevBlock} is the hash of the previous block in the chain. \emph{MerkleRoot} is the combined hash of all the transaction in the block, see section \ref{subsubsec:merkle_tree} for more on Merkle trees. \emph{Timestamp} is the approximate time of block creation and also serves as an additional source of variation for the block hash. \emph{Bits} is the targeted value the block's hash needs to be less than. It's encoded similar to standard IEEE754 floating point numbers with the exception that the signed bit is placed between the exponent and the mantissa instead of at the front. To convert to the target see formula \ref{eq:bits_to_target}. \emph{Nonce} is simply 32 bits of data that's only there to change the hash value of the block. This value is typically incremented during mining until a desired hash is produced and a block is considered solved, see section \ref{subsubsec:mining} for more on mining.

\begin{equation}\label{eq:bits_to_target}
\mathit{target} = (-1^{\mathit{sign}}) \cdot \mathit{mantissa} \cdot 256^{\mathit{exponent-3}}
\end{equation}

After this there is the data chunk which makes up the block payload. This data is divided into smaller chunks called transactions which are put end to end inside the payload. Since transactions are abstracted to only bytes there is no way of discerning the transactions by reading through a byte stream compared e.g. a series of zero-terminated strings. This is why we need transaction headers (TxHeader) which can tell us where a transaction is located in the block. It's a simple fixed-sized data structure so that it can be iterated over easily. It stores the transaction's offset into the data chunk and it's size. The transaction headers are located after the block header, but before the data chunk. The transaction headers are not really stored anywhere in the program and only really show up when a block is serialized or a transaction is being retrieved from the block.
% }
\begin{lstlisting}[float=h!,caption={Block Structure},label=lst:block_structs]
type BlockHeader struct {
  Version int32
  PrevBlock ShaHash
  MerkleRoot ShaHash
  Timestamp time.Time
  Bits uint32
  Nonce uint32
}

type MsgBlock struct {
  Header       BlockHeader
  Transactions []*MsgTx
}

type TxHeader struct {
  TxType   int32
  TxSize   uint32
  TxOffset uint32
}
\end{lstlisting}

\subsubsection{Transactions}\label{subsec:transactions}
The bitcoin protocol consists of exchanging messages between peers. The wire package implements everything involving messages. The main transaction structure in the btcd implementation is the MsgTx struct in the wire package. Any other transaction struct is just a wrapper around an inner MsgTx such as the Tx struct in the btcutil package.
%% Introduce the btcutil package
 To accommodate the new transaction structure all references to any TxIn or 
TxOut in the old struct were removed and replaced with a single byte slice. This way even unknown transaction formats can be accommodated as they can remain in serialized form indefinitely. To retrieve the underlying transaction in the byte slice a Type field has been added which holds a signed 32-bit integer representing what kind of transaction is in the serialized bytes. Each type may have it's own unique serialization and deserialization method. An interface has been added for making new transaction types easier and serve as a common ground for all transaction such being able to serialize/deserialize themselves. See code listing \ref{lst:transaction_structs}.

The Type and LockTime fields in the MsgTx struct are serialized together with the transaction. That way it's easier to set these fields without having to change RPC calls or make other changes where the transaction isn't a part of a block. So the first 8 bytes of a fully serialized transaction are these fields. The fields should ideally be removed from all serialized transactions and be moved to the transaction header instead. Currently the type is serialized in both places while the locktime is serialized only once next to the transaction itself.

\begin{lstlisting}[float=h!,caption={Transaction structure},label=lst:transaction_structs]
type MsgTx struct {
  Type     int32
  LockTime uint32
  Data     []byte
}

// List of transaction types and their numerical equivalent.
const (
  TxTypeUnknown  = -1
  TxTypeData     = 1
  TxTypeFile     = 2
  txTypeSignFile = 3
)

// Go interface for the type stored in MsgTx's Data field.
type TxInterface interface {
  Serialize(w io.Writer) error
  Deserialize(r io.Reader) error
  SerializeSize() int
  GetVersion() int32
  GetType() int32
}
\end{lstlisting}


\subsection{Btcd}
Btcd is the main program of bitcoin. This is the executable which starts the different server parts and connects to the network. 

\subsection{Btcctl}
Btcctl is a command line control client for communicating with btcd. It uses JSON-RPC for sending and receiving information from the node, blockchain, and network. It is implemented across many files, and this explanation will cover what is needed to add new functions to the btcctl. To use btcctl, username and password are required, as well as a server address with a port number, and of course, the name and arguments of the command to be called. 
% TOO detailed. Move to design? {
\begin{lstlisting}[float=h!,caption={Command handler type},label=lst:cmdHandler]
type commandHandler func(*rpcServer, interface{}, <-chan struct{}) (interface{}, error)
\end{lstlisting}

{\it{rpcserver.go}} is the main server of the RPC-service. Here is where the body of the functions are written and organized. Each of the functions is declared in a map of command handlers and a string representing them. The command handlers take arguments from users using btcctl to issue RPCs. This map of handlers allows the server to pair up the different RPC command strings with the appropriate handler at initialization. It is also here in rpcserver.go that each function is implemented, in the way of a handler, where each callable function is of the type commandHandler. The commandHandler type is a function that takes a pointer to a struct containing all of the server-specific information, an interface which contains the information of the RPC-request, and a channel structure to know it the client closes. The return values are an interface with the results to be sent with RPC back to the client, and an error if there are any.

If arguments are required from the user, they must be registered and declared in another file called {\it{chainsvrcmds.go}}. Here all the JSON-RPC commands supported by the server are housed, and when init() runs it generates the list of command names and arguments. The arguments for each command is declared with a function that takes the arguments from the user and adds it to an interface specified. 


\begin{lstlisting}[float=h!,caption={Command argument formatting},label=lst:cmdArg]
type ExampleCmd struct {
 Example string
}

func NewExampleCmd(ex string) *ExampleCmd {
 return &ExampleCmd{
  Example: ex,
 }
}
\end{lstlisting}

Returns from the RPCs are formatted in a similar fashion in a file called \textit{chainsvrresults.go}. A struct is declared for each command with complex return values, that is more than a single value. The RPC-service will use this struct to display to the user the results from the request made. 
 % }
 
\subsubsection{Uploading files}
Our approach for storing documents on the blockchain requires new API calls, because Bitcoin is designed for transactions of currency and small messages. The current btcctl commands are therefore lacking a few key calls to be able to for example upload and download files within transactions. The first call that we needed is a call to create a transaction containing a file or document, we called it \textit{createdatatransaction}.  It takes a filename or path and a transaction type integer, depending on what kind of transaction to create. Depending on the type variable, it creates the specific transaction with the file. The transaction is then wrapped by the general message transaction structure explained in \ref{subsec:transactions} .\textit{createdatatransaction} then creates a new RPC call, calling a function already implemented in Bitcoin, called \textit{sendrawtransaction}. This function takes a raw transaction and broadcast it to the network. It also checks if the transaction makes it into a block and if not, \textit{sendrawtransaction} rebroadcasts the transaction. 

\subsubsection{Downloading files}
When downloading file transactions from the blockchain, there are two choices, \textit{getfilebytxid} and \textit{getfilebyhextx}. These methods do what they are called, getting the files using the transaction ID(txid), a unique hex assigned to each transaction, or the hex-encoding of a transaction, called a raw transaction.  Because the hex-encoding of a transaction can become quite long, this function is best suited for small transactions. The first one, \textit{getfilebytxid}, is the best and easiest to use when handling files, due to the txid being of same length no matter the actual size of the file. 

Getfilebytxid takes only a txid as argument, and is built much like the create transaction function, only in reverse. It looks up the transaction from either the pool of transactions not yet included in a block, or the transaction database. Once the function has found the transaction, it checks the type variable with a switch case and unpacks the wrapper. From there, using ioutils WriteFile, it writes the file to disk in a chosen location. 

\subsubsection{Adding new transactions}
By using the general message transaction wrapper (TxInterface in code listing \ref{lst:transaction_structs}), higher modularity is achieved in this blockchain, and adding new types of transactions is simplified. A new type of transaction can be added to the system by adding a case to the main switch in  {\it{createdatatransaction}}, and a go-file containing the methods to adhere to the TxInterface type found in the message transaction file ({\it{msgtx.go}}). To cover the process of adding a transaction type to the system, lets use the transaction type called TxSignFile as an example. TxSignFile is a transaction that includes a file and a signature, based on the file itself and who creates the transaction using a private/public key pair. The process of adding this transaction type would start of by creating it in a file called after the transaction type, to be able to easily distinguish it from the other types. A transaction is built up with a structure containing the relevant information. This includes a version number for the transaction type, and is meant for later development and improvements to the transaction type. This should not be confused with the transaction type number, which is used to differ the different types of transactions. Apart from the version number, file name, the file itself, and the signature is what a TxSignFile struct contains.

The next step is to add the necessary methods so that the transaction type adheres to the TxInterface used by the message transaction wrapper. As the code snippet above describes, the TxInterface requires a way to serialize and deserialize the specific transaction, as well as a couple of get-methods to retrieve values from the struct. TxSignFile is now compatible with the message wrapper and can be sent in a transaction. The only thing missing is a constructor and a set-method for the signature byte array, because the signing itself is done elsewhere. 

How the system handles the new transaction type is programmed into the RPC server mentioned above. Both in \textit{createdatatransaction} and in \textit{getfilebytxid}, the existing switch based on the transaction type number, must have a new case appended. Inside the case is where the behavior is defined. For our TxSignFile we must make a new transaction using the specific transactions constructor, and add the filename and the file itself to their respectful fields in the TxSignFile struct. The signature field is the only one missing now, and will be filled shortly. This is done by first getting the private key to our client, either by generating a new key, or using an existing one. Using the private key's Sign method, taking the hashed digest of the file to be uploaded as input, generates a signature. This is then serialized and inserted into the signature field in the TxSignFile struct. Now the specific transaction is done and sent to a method to be wrapped in a general message transaction and broadcast to the neighbouring nodes. 

The TxSignFile transaction can now be included in the blockchain and sealed in the ledger, however there must be a way of accessing the signed file transaction. Fetching the transaction is done in the \textit{getfilebytxid} method, and the new transaction type must be added here as well for clients to get the file. The switch cases here describes how the different types of transaction are unpacked and handled. The TxSignFile needs to be unwrapped of the general message transaction wrapper, verified and then write the file to disk. Verifying the signature is done by first extracting the public key from the signature using the signature and file digest hash. Using the public key and the message hash, it should be able to verify that the signature is real and that the file has not been changed since the transaction was added to the blockchain. Once verified, the file is stored to disk and is accessible locally to the client. 

\subsubsection{Userfiles}\label{subsec:userfiles}
The basic user system that we implemented is built up of the User type and a login function. The User type has a username, password and a private key attribute. It is stored using the same serialization algorithm as with transactions, but stored in a folder called users. The User type has several methods available, although most of them are linked to aquiring and storing the private key. See Listing \ref{lst:user}.

\begin{lstlisting}[float=h!,caption={User},label=lst:user]
type User struct {
  Version  int32
  Username string
  Password []byte
  Key      []byte
}

func (u *User) Serialize(w io.Writer) error 
func (u *User) Deserialize(r io.Reader) error 
func (u *User) SetPassword(pw string) ([]byte, error) 
func (u *User) checkPassword(pw string) bool 
func (u *User) NewKey(pw string) ([]byte, error)
func (u *User) GetKey(pw string) ([]byte, error) 
func encrypt(key, text []byte) ([]byte, error) 
func decrypt(key, text []byte) ([]byte, error) 
func (u *User) copy() *User 
func (u *User) SerializeSize() int 
func (u *User) Save() error 
func NewUser() *User 
\end{lstlisting}

A user is made using the RPC call login with a username and a password as inputs. The password is set in the SetPassword method, were the password string is sent. This string is then hashed using SHA-256, and the hash is what is stored on file, not the password itself. When the password is set, many of the other methods can now be used, as they require the password to run. Passwords are checked in the checkPassword function, where it checks the hash of the password input with the hash it has stored. If these are identical, the methods continue. The new user also need a private key for sending signed transactions. To aquire a private key, the NewKey method is used by inputting the password of the user. If it checks out, a private key is generated, encrypted and stored as the users Key. 

The encryption used is CFB mode of operation. This is implemented using Go's crypto packages cipher and aes. The encrypt and decrypt are only called from inside other methods, which have already checked the password. The encryption process starts by generating a cipher block from the hashed password. Then the serialized private key is encoded with base64 encoding. Most encryption modes also requires a initialization vector(IV), which randomizes the encrypted string called ciphertext, so that even if the same byte array is encrypted again, the ciphertext will be different. Because it only needs to be unique and not secure, it is common practice to add it to the beginning of the ciphertext. The encrypter used needs the block cipher and the IV. Finally it XORs each byte in the slice with a byte from the cipher's key stream and returns the encrypted text, called ciphertext. See Listing \ref{lst:crypt} for the encryption function used.

\begin{lstlisting}[float=h!,caption={Encryption},label=lst:crypt]
func encrypt(key, text []byte) ([]byte, error) {
  block, err := aes.NewCipher(key)
  if err != nil {
    return nil, err
  }
  b := base64.StdEncoding.EncodeToString(text)
  ciphertext := make([]byte, aes.BlockSize+len(b))
  iv := ciphertext[:aes.BlockSize]
  if _, err := io.ReadFull(rand.Reader, iv); err != nil {
    return nil, err
  }
  cfb := cipher.NewCFBEncrypter(block, iv)
  cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(b))
return ciphertext, nil
\end{lstlisting}

\subsubsection{Login}

The login feature in this blockchain system is there to handle different users with their unique private keys. How the acual userfiles are built up and behave are covered in Chapter \ref{subsec:userfiles}. The login call takes username and password as input, and sees if it matches with existing users. If not, a new user is created with the username and password provided. The general structure of this call is a big if else tree, where it checks errors from os.Stat("filelocation") and react whether a file exists or not. The os package has a function called IsNotExist(error) to check if an error is known to report that a file or directory does not exist. 

If the user doesn't exist, it initializes a new user, and applies the username and password to the user, as well as generating a new private key. It then saves the user to file, storing the password and private key securely in a file called by the username in the folder users. After the user has been saved, it can be transferred by copying the userfile to another instance of btcd, if a user needs to sign a file in another instance. The login call is mostly used by the transaction creator, but it can be called individually to return the serialized private key. 

\section{Evaluation}
Evaluate project. What worked what didn't, etc. 

In this chapter we present our implementation of a generalized blockchain. We will discuss a few use cases where we will explain how to send or receive transactions using our new blockchain system. Finally, we will discuss future improvements to the blockchain, including a proper frontend and a synchronized user system.

\subsection{Setup}
To start using this blockchain system, btcd needs to be running on the client machine, so that it can connect to other nodes on the network. We will use btcctl to do all communication with btcd, regarding transactions, as well as logins. Btcd will start by synchronizing to nearby nodes, to make sure it's working on the same chain as the rest of the network. The synchronization should complete in a short period of time, as this is a separate chain from bitcoin's blockchain. When the synchronization is done, btcctl can be used to communicate with btcd's RPC server. Listing \ref{lst:start} shows a start command example, where the different settings are specified, although a user can also set these in the config file(btcd.conf). With the settings pre-defined, the program can be started simply with ./btcd.

\begin{lstlisting}[float=h!,caption={Start-up command example},label=lst:start]
$ ./btcd -u username -p password --rpclisten=127.0.0.1:8445 --listen=192.168.1.96:8444
\end{lstlisting}

\subsection{Use Cases}
There are many ways to use a more open blockchain system like this, due to the general transaction message wrapper implemented. There are no restrictions to transaction types other than that they will have to implement the TxInterface mentioned in Chapter \ref{subsec:transactions}. By making the transaction format this general, we open up the blockchain to be used for storing any type of data. As of yet, there are three implemented transaction types to be used, a general data transaction, a file transaction and a signed file transaction. The type is selected by the second input to btcctl when creating a transaction, as shown in Listing \ref{lst:btcctl}. Type 3 refers to a file transaction.

\begin{lstlisting}[float=h!,caption={Transaction creation command example},label=lst:btcctl]
$ btcctl -u username -P password -s localhost:8445 createtransaction "/tmp/test.md" 2
\end{lstlisting}

The general data transaction is the most general form we have made. It can be used for any type of data as it only contains a byte array. This type of transaction was intended to use to hold a hash value of a file for verification processes and proof of existence. The uploader could point to this timestamped transaction and verify that the data the hash was made from existed at the time. If the user wants to not only have proof that the file existed, but store the entire file in the blockchain, it is possible to use this type of transaction. The problem is that deserialization must be customized to the file. A solution to this is the other two transaction types, which are made to handle files and not just a data array. 

The file and signed file are very similar in their structure. Their only difference is the signed file transaction type holds a signature of the uploader. This way, an uploader can choose whether or not to be anonymous, although a signed file is safer for the potential downloader. When making a signed file transaction, password and username must be added as inputs to the transaction creating RPC call. With a signature in place the users can verify that the file was actually sent by the correct sender before saving the file to disk. The userfiles can also be sent in transactions with password and private keys intact, to be downloaded on another client. Downloading userfiles allows users to have access to their userfiles on every node.

Receiving or downloading data or a file is just as easy for the user. Simply use the transaction id as input in the RPC call called \textit{gettransactionbytxid} and it will automatically use the correct unpacking for the specific transaction type. 

\subsubsection{Verifying Documents}
Verifying documents using our blockchain system is a use case we focused on from the start. Institutions like universities could use the blockchain as a verifying system for diplomas and other documents where tampering is a risk. By having known public keys, and using the signed file transactions, institutions could sign diplomas using their private keys. This would effectively make the transactions verifiable as other entities like other schools or businesses could check if the diploma in the specific transaction was sent by a known public key, owned by a school or university. 

Alternatively, a diploma could be hashed and the hash sent in a transaction, which would add the benefit of complete secrecy regarding the diploma. The verifying process would be similar to the previous use case, only with an added step of hashing the received diploma to check if the hash values match up. This way a school receiving a digital diploma could check with the blockchain to see if the hash values are the same, without having to store the entire document on the blockchain. This technique would benefit the blockchain more, as the size of each transaction would be a fraction of saving the whole file. This way the blockchain would serve only as a verification system and would only supplement another storage server. 

\subsection{Future Enhancements}
\subsubsection{Additional Encryption}
When dealing with data that may be private, security is always very important. The security of users can be enhanced in the form of adding a second layer of encryption on the saved user file. As of May 2016, this system saves users serialized with username and password hash in plaintext. This opens up for social engineering weaknesses where an attacker could try to guess the password based on the username. By encrypting the entire file using a combination of username and password as the key, every plaintext part of the file would be encrypted, effectively reducing the risk of unauthorized access to the user. 

The actual files on the blockchain also lacks an encryption option. Adding a new transaction type with encryption, or implementing encryption in the existing transaction types would greatly enhance the security and privacy of stored documents. With the file encrypted, only users who knows the password to decrypt the file, would get access to the file content. Such a feature would make this system safer for storing files that should be secret, like diplomas or internal documents. 


\section{Conclusion}
What to take away/learn from this project.

\newpage
\bibliography{references} 
\bibliographystyle{ieeetr}
\listoffigures

\end{document}