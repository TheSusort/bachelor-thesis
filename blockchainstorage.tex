\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{float}
\usepackage{titling}
\usepackage[nottoc]{tocbibind}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[font=footnotesize]{caption}
\usepackage{subcaption}
\usepackage{pageslts}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usetikzlibrary{shapes, arrows, positioning, calc, patterns, decorations.pathreplacing}

% Hyphenation rules
\hyphenation{block-chain}

\graphicspath{ {./graphics/} }

% \figMembership defined in this file.
% \figBlockTxStructure defined in this file.
\input{figures.tex}

%\setcounter{page}{1}
\title{Verifying Diploma with Blockchain Technology}
\author{Kenneth Susort \and Christer Jensen}
\date{\today}

\setlength{\parindent}{3em}
\setlength{\parskip}{1em}

\begin{document}
\pagenumbering{arabic}

\begin{titlepage}
	\begin{center}
		
		\huge
		\textbf{\thetitle}
		
		\vspace{0.5cm}
		\large
		How can the Bitcoin technology be used\\ for validating academic diplomas?
		
		\vspace{0.5cm}
		
		\textbf{\theauthor}
		
		\vfill
		
		A thesis presented for the degree of\\
		Bachelor in Computer Science
		
		\vspace{0.8cm}
		
		\includegraphics[width=0.2\textwidth]{university_logo.png}\\
		\large
		IDE\\
		University of Stavanger\\
		Norway\\
		\thedate
		
	\end{center}
\end{titlepage}

\pagenumbering{roman}

\begin{center}
	\vspace*{4cm}
	\textbf{\textit{Abstract}}
\end{center}


This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes. This is where the abstract goes.
\newpage

\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{\theCurrentPage}

\section{Introduction}

Blockchain is a technology which is used in different types of cryptocurrency. Cryptocurrency is a medium of exchange or currency, and is entirely digital. It is made possible by utilizing certain principles of cryptography to secure transactions and to control the creation of new coins added to the circulation. What differs cryptocurrency from normal banking system is how the currency is controlled. Regular banking systems uses what is called centralized control, where the banks alone are in control over what money is spent where. Cryptocurrencies uses a decentralized system, which hands over control of the currency to its users and contributors. Such a system relies completely on the assumption that there are more honest than dishonest users. Due to this, the more a cryptocurrency grows, the more secure it becomes. 

% Rewrite the below section.
Falsified diplomas is something a lot of institutions struggle with. This thesis proposes a solution to this problem, by using blockchain technology to store hashes of diplomas in series. The hashes are then hashed together using a Merkle tree hash structure. This allows storage of an unchangeable hash that only the publisher of the original diploma would be able to prove ownership of. Attempts of changing stored documents will change every hash after said document, due to the blockchain structure. The goal is to design a hybrid consortium blockchain, which would use signatures from different institutions to validate a diploma, and locking it in the blockchain with proof-of-work. 

\section{Background}
The background section explains what the blockchain is, and what purpose the blockchain serves. The blockchain can be seen as a huge linked list of blocks containing transactions. What the different aspects and developments of cryptocurrency and the blockchain in general is a bit more complicated and will be explained further down. The benefits and drawbacks of the variations of blockchains that exists will also be explained, focusing on the more popular with the intent on finding what would suit validating documents best. 

\subsection{Bitcoin}

Bitcoin is a digital decentralized currency conceived in a paper by Satoshi Nakamoto\cite{nakamoto2009bitcoin}. Transactions works without an intermediary, like a bank, but rather peer-to-peer. Transactions are validated by nodes that updates the blockchain, which is a ledger containing every transaction made. These nodes offer computation power, or CPU cycles to record and verify the transactions in this ledger. This is called mining, and the nodes are called miners, because the reward for verifying and adding to the blockchain, is transaction fees for every transaction and the chance to unlock, or mine new bitcoins. For every new block in the blockchain that is validated, a set amount of bitcoins is made, and given to the miner who validated the block. This amount is decreasing by a set amount, and the difficulty of mining is increasing by total amount of mining power, so that it will take about 10 minutes between each successful mining.

The greatest challenge with cryptocurrency up until Bitcoin, was Byzantine fault tolerance, and it's still a concern with the bitcoin blockchain. A system that has the characteristics of Byzantine fault tolerance, is a system that tolerates or handles a type of failures known as Byzantine Generals' Problem\cite{lamport1982byzantine}. The Byzantine Generals' Problem is best explained with a thought experiment, where Byzantine generals each command their portion of an army. The problem to be solved is how do they they decide whether to attack or retreat, when all generals must agree on one decision. A partial attack may end in disaster for the attackers, and a gathered attack or retreat would be more effective. The situation is further complicated when the possibility of corrupt generals and messengers arises, and the problems that they would bring.

For example, if there was 5 generals, and two voted for and two voted against, a corrupt general could send a vote to each party. This would result in each half of the army attacking and retreating, thinking that the entire army is doing the same thing.  Messengers could also deliver forged messages or deliver none at all. The Byzantine Generals Problem transfers very well into computer systems, especially distributed systems, where many computers are working together to achieve the same goal. In cryptocurrency, the Byzantine Generals Problem is very important, because most cryptocurrencies is based on a network of computers working together to strengthen the ledger by deciding the order of transactions. There has to be a way of reaching consensus between all of the nodes. Byzantine fault tolerance is achieved when the honest nodes can reach consensus even with the possibility of corrupt nodes. In cryptocurrency, BFT is achieved when atleast 51\% of the total computing power is used honestly. This is done through a process called mining.
 
In the beginning, you could mine with your own personal computer, utilizing the CPU and be profitable. Then when more computers were utilized as miners, the difficulty increased so that it was less profitable to just use the CPU. Since mining is  simple hashing of a value, people figured out that graphical processor units, or GPUs, where better suited for mining than CPUs, and so the norm changed to using GPUs, which could produce a much greater rate of hashing. Then came the ASICs, which are dedicated mining machines and can produce even higher hash rates. Present day, miners gather their computational power in collaboration to increase their success rate, and sharing the mined bitcoins between every member, based on how much each individual contributed to the group. This is currently is the most profitable way of mining, though the electrical cost is catching up to the profitability of the current ASICs.

This method of validating transactions is called proof of work, and uses computational power in exchange for currency, is widely used in other cryptocurrencies as well as Bitcoin. Other proofs, or methods of validating transactions without a central bank or intermediary, has emerged since Bitcoin went public and became popular. Proof of stake, proof of burn, and proof of activity is examples of a few. These use different  types of approaches to validating and keeping track of transactions. Proof of stake needs miners to prove their ownership of their share in the currency. Peercoin, which implements proof of stake, uses coin age, or how long the coins have been held by a miner to increase chances of successfully validate the transaction ledger. Proof of burn requires miners to burn, or send part of their coins to an unusable address, for validating transactions and unlock new coins. 

The blockchain is by far the most fruitful idea that comes with bitcoin. It's a linked list containing hashed blocks of transactions, linking to each other in a specific order. The hashing makes it very hard to alter anything on the blockchain, due to the fact that it is practically impossible to get the same hash values from different data. An individual or group with the intent of changing something in the blockchain would have to have 51 \% or more of all the computational power currently participating in the blockchain. This way, as long as there are more honest blockchain contributors than dishonest, the chain will not be compromised. If there is a difference in a block, or two blocks get solved at the same time, a fork will happen. This fork will continue till one of the competing chains is longer than the other, and the shortest will be annulled and discarded. 

Blocks in the blockchain is the building stone. A block is comprised of a header and a body. The header contains a version number, the hash of the previous block in the chain, a Merkle root of the transactions, the current difficulty, and the nonce. The previous block hash is there to link all the blocks together, so that if someone with ill intent changes something already in the blockchain, the hash values will differ and the nodes will read it as a fork of the main blockchain. Whether or not they work on it, comes down to how fast the different forks advances and solves new blocks. If you had 51 \% of the computational power, you could make a change and everyone would work on your fork, because you would win every race against competing forks.

The Merkle root\cite{merkle}, is a tree structure where the parents value is a hash of its children. So to check if two competing blocks are different, you would only have to check the Merkle root hash. The current difficulty of the blockchain, is the number of zeroes at the start of the hash. A nonce is a cryptographic term for a word or number used only once. This is the answer to the proof of work. The body contains all the transactions to be stored. These transactions are hashed only indirectly through the Merkle root. Because of this, a block takes the same time to hash its transactions, independently of the number of transactions. This also makes it easy to browse every transaction ever made, using a hex editor.
 
BFT in Bitcoin and other proof-of-work cryptocurrencies is achieved by having each node in the network work to solve a hashing problem. The goal is to find the right hash, using the blockheader and a nonce. This is regulated by the difficulty of the chain, which changes every 2016 blocks, to ensure that it takes about 10 minutes to find each right answer. The right answer is found when the resulting hash of the blockheader with the nonce is lower than the current difficulty. In more practical terms, since the difficulty is regulated by how many zeroes the hash starts with, needs to have more zeroes in order to be the right proof-of-work.

\begin{figure}[h!]
\begin{equation*}
\textrm{DSHA256}(\textrm{data}) = \textrm{SHA256}(\textrm{SHA256}(\textrm{data}))
\end{equation*}
\begin{equation*}
\textrm{DSHA256}(\textrm{Blockheader}) < \textrm{Difficulty}
\end{equation*}
\caption{Proof-of-work goal}
\end{figure}

Once a hash with lower value than the difficulty is found, the miner broadcasts this to the network. The neighbours can easily check if the answer is correct by hashing the nonce that was received and the blockheader. If the nonce appear to be correct, they will broadcast it to their neighbours again and drop their own mining to continue on a new block on top of the recently discovered one. This process will continue till the entire network knows of the new block. There can be more than one right answer so if two miners solve a block at the same time, forks will be created and worked on till one of the forks has solved more blocks than the competitor. The losers fork will then by annulled and dropped, along with any currency that were received from mining on the losing fork. This way BFT is maintained as long as the majority of nodes are honest.

\subsection{Transactions}

The transactions are the biggest part of a block. Here every transaction ever made in the cryptocurrency is stored and fully browsable. A transaction is a transfer of a set value currency that is broadcast to the network of nodes, or miners. The Bitcoin network is made based on best effort, meaning that there is no certainty that a transaction is picked up by a miner and put into a block. Instead of forcing miners to pick up every transactions, there is a transaction fee that goes to the miner when a block is mined. This fee is completely optional, but advised. A miner has no incentive to pick up a transaction without transaction fee, other than to fill up a block. Choosing to pay a higher transaction fee will make miners want to pick up the transaction and will be confirmed in a block sooner. 

In the Bitcoin network, there are no Bitcoins, either physically or in a digital file. There are only the ledger of transactions, that when summed up gives the current value to each wallet. A bitcoin wallet is just an address to send and receive the currency to. The address is comprised of 26 to 35 alphanumerical characters beginning with the number 1 or 3, depending on what type of wallet it is. Each wallet, or address, has a public key and a private key. The private key is created using secp256k1\cite{sigalg} and is a 256-bit string of random data. A copy of the private key is then deterministically transformed into a secp256k1 public key. The public key can be repeatedly generated at a later time, so there is no need for it to be stored. 

The public key is then hashed and encoded as bitcoin addresses. The hashing of the public key is done to obfuscate it, and make it impossible to decipher the private key from it. Any users with the public address can send bitcoins to the address, using transaction scripts, by decoding the bitcoin address to the public key hash. The private key is used for creating a signature to redeem any potential transactions to the public address. Best practice with transactions and addresses is to generate a new address for each transaction, because every transaction is public and browsable. This makes tracking of your transactions virtually impossible. 

\begin{figure}[h!]
	\begin{lstlisting}[ basicstyle=\tiny]
Input:
Previous tx: f5d8ee39a430901c91a5917b9f2dc19d6d1a0e9cea205b009ca73dd04470b9a6
Index: 0
scriptSig: 304502206e21798a42fae0e854281abd38bacd1aeed3ee3738d9e1446618c4571d10
90db022100e2ac980643b0b82c0e88ffdfec6b64e3e6ba35e7ba5fdd7d5d6cc8d25c6b241501

Output:
Value: 5000000000
scriptPubKey: OP_DUP OP_HASH160 404371705fa9bd789a2fcd52d2c580b65d35549d
OP_EQUALVERIFY OP_CHECKSIG
	\end{lstlisting}
	\caption{Bitcoin Transaction}
	\label{fig:transaction}
\end{figure}

A transaction is built up of a variable number of inputs and outputs. See figure~\ref{fig:transaction}  for an example. Since all bitcoins are just references to earlier transactions, inputs are mostly references to which previous unspent transaction is being spent. There can also be as many input as needed, depending on how fragmented your wallet is. The index section of the input of a transaction, represents the index of the previous transaction. This is needed because there can also be several outputs to a transaction.

The scriptSig value represents the first half of the transaction script. It contains a public key and a signature. The public key has to match the output hash of the previous transaction from the output script, called scriptPubKey. The signature, combined with the public key, is used to prove that the transaction in question was created by the owner. It is a secp256k1 signature over a hash of a simplified version of the transaction. 

The output section of a transaction contains a value and the second part of the script. The value is the amount of bitcoin that is being transferred, measured in satoshis. A Satoshi is the smallest unit of a bitcoin, worth one hundred millionth of a bitcoin. In the example figure, the amount that is transferred is 50 bitcoins. The script part of the output is called scriptPubKey. This contains the different steps to redeem the transaction by the receiver. This involves checking if the receivers signature matches with the public address in the transaction. 

There are two main types of transactions, Pay-to-PubkeyHash and Pay-to-Script-Hash.	These will be referred to with the abbreviations P2PKH and P2SH. P2PKH is the simpler one, and used for transactions to one or multiple bitcoin address, and requires only proof that the recipient has control over the private key that corresponding to the hashed public key. This is done with a signature script that checks if hashing the full unhashed public key of the recipient corresponds to the hashed public key hash sent by the sender.

P2SH is made with the intent of creating more complicated transactions. It allows setting of more conditions for the transaction to be spent. This is implemented by instead of using a hash of the public key, a script with the conditions is hashed and encoded to a standard bitcoin address, with one change from P2PKH. The address starts with the number 3, instead of the number 1, which describes a P2PKH address. 
\subsection{Different Blockchains}

The popularity, and therefore its worth, of Bitcoin has significantly increased since its introduction in 2008. Since it's controlled purely by supply and demand, the increased popularity has made the worth of a bitcoin gone from just a theoretical currency to a multi billion dollar trade, where the price of a single bitcoin has been as high as 1000 USD. After the bankruptcy of Mt. Gox, a bitcoin exchange handling about 70 \% of all transactions, where several hundred thousands of customers bitcoin where lost or stolen, the bitcoin took quite a hit, and hit the bottom at about 20 \% of what the value once was. Since then, the price has been steadily increasing again, and at present time is about 450 USD. With this increase in popularity, the cost of mining will surely continue to increase, and the need for cheaper alternatives to proof of work, or at least alterations, is increasing with the cost of mining.  

This design has grown in popularity also outside the cryptocurrency field, because of its ability to store something publicly without revealing what the data is. Industries which are researching ways to utilize the blockchain include, but not limited to, banks, stock exchange, document signing, realty, cloud storage, and many more. 

The original blockchain uses proof-of-work to validate transactions, by making a node spend computational power in exchange for the chance of mining a block. Bitcoin utilizes the Hashcash\cite{hashcash} proof-of-work system which works by hashing a base string and a nonce together, changing the nonce for each try, until the resulting hash is lower than the difficulty. An easier way to explain this is to count the amount of zeroes a hash starts with. The more zeroes, the lower the value, the more difficult it becomes to get. Because of the randomness that is SHA-256 hashing, it is almost totally random who will solve the proof-of-work first. Because of Bitcoins popularity, the Bitcoin blockchain has become increasingly difficult to mine. Different suggestions has come up to try and improve or replace this original SHA-256 proof-of work. 

Litecoin is the second most popular cryptocurrency as of yet. It is, as its name suggest, a lighter currency, compared to Bitcoin. Litecoin still uses proof-of-work as validation, but has made changes to overcome some of Bitcoins problems. Introducing scrypt, Litecoins proof-of-work system, utilizing more memory and makes it easier for normal computers to contribute and still make a profit. It still uses Bitcoins SHA-256, but as a subroutine. One of the drawbacks of scrypt is because it is easier for regular computers to mine, it is also more at risk for botnet exploitation or attacks. Big enough botnets have a greater chance of double-spending on a blockchain using scrypt than Bitcoins SHA-256 proof-of-work.

Moving away from proof-of-work, there are several other proof-of-x with different benefits and drawbacks. Proof-of-stake, first proposed on an online forum by a user named Quantum Mechanic, uses the currency itself as a stake to mining a new block. The way it works is by proving ownership of currency, and in return there is a chance to mine the next block. The more currency is held, the greater probability to unlock more. This is one of the big drawbacks with proof-of-stake, where the rich becomes richer. There are several implemented solutions to this, using randomization, coin age or movement. The most popular implementation of proof-of-stake is Peercoin, which utilizes randomization and coin age to achieve consensus. The probability of mining a block is calculated from the amount of coin, and how long the coin has remained in the specific wallet. Coins become able to compete for a block after 30 days, and will continue to increase in probability until it has gone 90 day, when the probability reaches a maximum value. Implementations based on movement, rewards coins that in exchanged more, with higher probability of finding the next block. 

One of proof-of-stake's biggest advantages and drawbacks is the cost. Because the currency is also the means of mining, there is little at stake outside the currency. Bitcoin mining uses on average 240kWh per bitcoin, which is a considerable cost, when you factor in the purchase cost of the ASICs that do the mining. The International Energy Agency states that for each megawatt(MW) of power spent, results in 650kg of CO2 released into the atmosphere. This means that for every bitcoin mined, 156kg CO2 is released. A proof-of-stake blockchain does not have this problem, but that also means that it is cheaper to exploit, by mining several forks at once. To combat this, Etherum, which is a blockchain for app development, suggested a system where you could punish anyone who was mining several blockchains by making them double sign. This was never implemented because Etherum went with proof-of-work. 

Because of the expense of proof-of-work, there is always incentive to find an alternative, preferably with lower cost and greater security. In the years following the phenomenon of Bitcoin and cryptocurrency, from being a pretty much worthless number on your screen, to its now total multi-billion dollar worth, other big institutions have noticed the potential of the blockchain. Recent years there has been a great increase in ways of using the blockchain, not only for currency and exchanges, but for all kinds of areas needing a ledger.

R3 is a company that is currently developing ways to implement the distributed ledger that is the blockchain, into banking and stock markets. It has gained enormous support from the industry, and is currently being backed by most of the worlds biggest banks and financial institutions. The distributed ledgers that they are creating, are not the open public blockchain that everyone can contribute to, as known from cryptocurrency. Instead they are building it to be a consortium blockchain, which instead of proof-of-work to mine a new block, will require signatures from all of the members in the consortium. Incentive to keep nodes honest doesn't matter in this case, because every node is confirmed honest, there is no point in proving that the work has been done. In this manner, institutions can have a distributed ledger which is virtually tamper proof. 


\section{Design and Architecture}

In this section we will go over each part of the blockchain validation system. The blockchain will feature centralized management allowing more control of what goes into the blockchain compared to other decentralized system.

\subsection{The Blockchain}

\subsubsection{Merkle Tree}
This is a reference.

\subsection{Blockchain Authority}

The authority of what goes into the blockchain is decided by a certain percentage of member votes. The list of authoritative members is kept on the blockchain itself and is due to change as new blocks are added. This way new members may be added or removed, but only under the authority of already existing members. This will leave a small by flexible number of central members in control over the blockchain. The system works by having each initial authoritative member give a public associated address which would identify him and add this to the initial block in a series of add transactions. Each client would store a list of all public addresses from any add transactions. This membership list would then be further modified by the client as any add/remove transactions were included in new blocks. However seeing that blocks need a certain percentage of votes to be accepted into the chain means that authoritative members could refuse to vote on blocks containing malicious transactions such as a client trying to add himself. These votes comes in the form of a digital signature that is added to the block. Only if a block has enough signatures should a block be considered valid and processed onto chain. 

\figMembership{How membership change}{Each block is tied to the previous block and contains a set of transactions. The top row is the blockchain itself. The bottom is the current membership list at that block.}

On Figure \ref{fig:membership} you see an example. The first block, which is refereed to as the genesis block, is the first actual block in the chain and is typically hard-coded into program itself. This block, block 0 here, will contain a set of transactions adding an initial list of members. This block requires no signatures as the previous block, null, starts off with an empty list of members, see (a). When block 0 has been accepted and processed all members from any add transactions will be added to the internal membership list, this would create the initial membership list, see (b). Any blocks from that point on would in this example have to have $\frac{2}{3}$ or greater number of votes from all the members on the membership list to be considered valid. The specific membership list would be the one this block is built on top of. At (c) we see a new block being added that is based on block 0. This block has in its signature field the signatures of both A and B, this makes this block a valid block and it is added to the chain. This block contains the transaction to add D and remove C so the internal membership list is updated. The next block that builds on top of block 1 would have to contain two signatures from either A, B or D.

\subsection{Storing Documents}

There is no limit on the kinds of data you can store on the blockchain. The blockchain e.g. Bitcoin uses however are very restricted in what goes into a block and only allow bitcoin transactions. It is still possible however to store file in the form of a hash. Bitcoin's signature script has an operation called OP\_RETURN which returns up to 40 arbitrary bytes. These bytes would contain the hash of the file you wish to store and can be used later to prove the existence of this file as well as a possible ownership later by verifying transaction ownership the same way Bitcoin verifies bitcoin ownership.

One of the drawbacks of this approach is that you have to pay a miners fee just like any other transaction. Since the miners fee is based on the size of the transaction big transactions such as a whole file, not just the hash, could end up taking up an entire block worth of space and be very expensive to include into a block. You also can't put a lot of extra data together with the block and as such can't create bigger data structures.

Our approach is to allow a set of transactions in each block however instead of being under the assumption that these transactions be under the same format we generalize it. Each transaction in the block can be thought of as simply a set of arbitrary data. In the block header you would have a list of all the transactions the block contains as well as an type id saying what kind of transaction this is. It is the authoritative members job to allow and disallow transactions based on type. This makes it easier to expand the blockchain with more types of transactions as only a smaller subset of nodes need to be updated to handle this new type. Other non-authoritative members would simply accept blocks with unknown transactions types. This makes the blockchain more flexible in what in can store.

\figBlockTxStructure{Example of transaction abstraction}{Shows a simple structure of the transactions within the block. \#Tx is the number of transaction headers. Each header stores a pointer and a size which says where in the main data chunk this transaction is located. This allows for variable sized transactions.}

A possible transaction could be storing a diploma for finishing a university degree. It would include either the document itself or a hash of it together with a public address of the recipient of the diploma and a signature belonging to the university which handed the diploma out. This information could be retrieved later and together with the signature serve as proof of the diplomas validity. Other uses could be to timestamp and preserve research papers across research institutions. 

% TODO: Add example of transaction body?

\subsection{RPC}
Bitcoin Core uses a remote procedure call(RPC) interface encoded in JSON for communication. This allows users to access information about the blockchain, and execute various administrative tasks. With these RPCs users can make queries about network and blockchain data, and with our implementation, queries about the different transactions and what diplomas they contain. Remote procedure calls works by having a program execute a subroutine in another address space, often on a different computer or a shared network. The executable on the remote computer is coded essentially the same as if the subroutine were local or remote to the executing program. 

JSON-RPC works by sending an inquiry to a server with the JSON-RPC protocol implemented. The server listens for specific HTTP-POST requests on certain portnumbers and uses only the basic access authentication provided with HTTP. However, by default the RPC service is not accessible to other servers, due to it binding to your servers localhost loopback network interface. This provides an interface for controlling and adding to the blockchain

\newpage
\bibliography{references} 
\bibliographystyle{ieeetr}
\listoffigures

\end{document}